/*!
  * Bootstrap v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function  (t ,  e ) { "obj ec t" == typeof e xp orts && "un de fined" != typ e of module ? mo d ule . exports =  e( ) : "function "  == typeof  d efine &&  d ef i ne.amd ? de fi ne(e) : (t = "und e fined" !=  t y pe of globalThis ?   glo balThis  : t || s el f ).bootstrap =  e() }( t his, (function ( )   {  " u se st r ict"; const t = "transitionend",  e  = t  = > {  le t  e  = t. g etAttribute("data-bs-ta rg et" );  if (!e || "#" = ==  e) { let i = t.get Attribute("h ref"); if (!i | |  !i.includes("#") & &  !i . startsWith(".")) return   n u ll ; i .in c l udes("#" )  &&  ! i.starts Wi t h ( "# " ) && (i   = `#$ {i.split (" #")[1]}`), e = i && "#" ! = =   i ?  i. t r i m( )  : null   } ret urn e },   i = t => { const i = e(t) ;  ret ur n   i  & &  document.querySelector(i) ?  i  :   n ul l },  n  = t =>  {  const i =  e (t); re tur n i ? do cu me n t.quer ySelec tor (i) : null } ,   s  =  e = >  { e.dis p atch E v e nt(new E ve nt(t)) } ,  o = t =>   ! ( !t || "object" != typeof  t ) &&  ( v oid  0  ! ==   t.jquery && (t = t[0]), v oi d  0 !==  t .node T y pe),  r   =  t  =>  o (t) ? t.j q uery  ?  t [ 0]   : t :  " string" == typeof t && t.length > 0 ? document.querySelect or(t)  :  null, a = (t, e, i) => {  Object.keys(i).forEach((n => { const s = i[n], r = e[n], a = r && o(r) ? "element" : null == (l = r) ?  `$ {l } `   :  {}.toSt ri n g.c all(l).match(/\s([a-z]+)/i )[ 1].toLowe rCa se(); var l; if (!new RegExp(s).test(a)) throw new  T y p eE rr or (`${t.toUp per Case()}: Option " ${ n}" provided type "${a}" but expec te d type  "${ s}".`) }))   }, l = t = >  !(!o(t) || 0 === t.getCli en tRects( ).l ength) && "visible" === getC o m p ut e dS tyle(t).getPropertyValue("visibility"),  c = t => !t  ||  t.nodeType  ! == Node.ELEMENT_NODE  | | !!t.c l assList.contains ("disabled") || (void 0 !== t. d i s able d  ? t.disabled : t.hasAttribute ( " d isabled") &&   "false" !== t.g e tAtt ri b u te (" d is a b l ed " )), h = t => {  i f   (! do c ument . documen t E l ement.a ttachSha do w) return null; if ("function" == typeof t.getRo o t N ode)  {   c ons t   e  =  t.get Roo tNode(); return e instanceof  S h a do w Root ?   e  :  n u ll } re t urn  t  ins t anceof  S hadowRo o t  ? t : t .parent N ode ? h(t.parentNo de) : null }, d = ( )  = > { }, u = t => {  t .o ff setHeigh t  } , f = () => { cons t  {  jQuery:  t }  = window; return t   && !docum en t.body.hasAttribute("data-bs-no-jquery") ? t  : n ul l  }, p = [],  m  = ()  => " rtl" === d o cum en t . d oc u mentElemen t. dir, g =  t  =>  {   v ar  e;   e  =  ()   =>  { c onst e = f(); if  (e) { c o ns t  i  =  t.N AME, n =  e.f n [i]; e.fn[i] = t.jQ ue ryInterface, e.f n [ i ].Constructor = t, e.fn[i]. noConfl i ct = () => (e.fn[i] =   n , t.jQueryInterface)  } }, "lo ad i n g"   === document.rea d y State ? (p.lengt h | |  document.addEventLis t ener("DOMContentLoaded " ,  (()  = >  { p.f o rEa ch((t = >  t ())) }) ) ,  p. p u sh( e ))  :   e()  }, _ = t => { "function " = = typ eo f t && t() }, b = (e,  i,  n = !0) => {  if   ( !n ) re tur n  vo i d  _( e) ;  co ns t  o =  ( t => { if (!t )  ret urn  0 ; let { tra ns i t ionDurat i o n : e , trans i tionDelay : i } =  wi n d o w .ge t Co mp u te d St y le( t); const n =  Number.par s e Floa t( e ) , s = Number.parseFlo a t (i); re t u rn n || s   ?  (e  = e. s pl it(",") [ 0 ], i = i.sp lit(",")[0],  1e3 * (Num ber.parseF lo a t (e) + Number.parseFloat(i)))   :  0 })(i) + 5; let  r = !1; co nst a = ({  target: n } ) => { n === i  && (r = !0,  i.removeEventList ener(t, a),  _(e)) }; i. addEventList ener(t, a), se tTimeout((()  => { r ||  s(i) }), o ) }, v =  (t, e, i, n) => { l et s = t.inde xOf(e); if ( -1 === s) r eturn t[!i &&  n ? t.length -  1 : 0]; const  o = t.lengt h; return s +=  i ? 1 : -1, n &&  (s = (s + o) %  o), t[Math.max( 0, Math.min(s , o - 1) )] }, y  = /[^.]* (?=\..*) \.|.*/, w  = /\..*/ , E = /::\ d+$/, A = { }; let  T = 1; co nst O = { mouse enter: "m ouseove r", mouseleave: "mo useout" }, C = /^(m ouseente r|mousel eave)/i, k  = new Set(["c li c k", "dbl cl ick", "mouseup ",  "mousedow n" , " c ontextmenu",  " mousewh e el",  "DOMMouseScroll",   "m ouse o ver" ,  "mo useo u t", "mousemov e" ,   "sele c tstart" ,  "selectend", " key down",   "k e y press", " k e yu p",  " orienta t ionchang e" , "touchstart", "t ouc h mo ve", "touchend", "to uch ca ncel", " p ointerdown" ,  "pointermove ",  " p ointeru p ", "poin te rleave",  " p o i n t er cance l ", "g esturestart", " ge st u rec han ge ",   "gestureend",  " fo cu s" ,  " blur", "c ha nge", "r es et" , "sele ct ",  " su b mi t " , "foc usin", "fo c usout",   " lo ad", "un loa d ",  "beforeunload",  "r esize", "move",  "D OMContentLoaded" ,  "readystatechange", "error", "abort", "scrol l"]); function L(t,  e )  {   r e turn   e   && ` $ {e}:: ${T ++ }`   || t .u idE v e nt ||   T ++ }  f uncti o n x( t )  { c on s t   e  = L(t );  re turn t.uidE vent = e,   A[e] = A [e ] | | {}, A [ e] }  function D( t, e,   i   =  null) {  co ns t  n  = Object.keys(t); f o r (let  s  = 0, o = n.length; s  < o ; s+ + ) { con s t   o  =  t [ n[s ]]; i f   (o.originalHandl er ===   e && o.de legatio nSele cto r  === i) return o } retur n  n ull } fu nc tion S(t , e, i)  {  co nst n = "s tring " == typeof   e, s  =  n   ? i : e;  le t  o  = P(t); return k.ha s (o) || (o = t), [n, s,  o ]  } functi on  N(t, e,  i, n,  s)  { if ("str ing"   != t ype of e || !t) return;  i f   ( i  || ( i = n, n = null),   C. test(e))   {  const t =  t  = > fu n ct ion (e) { if (!e.rela te dT a rget || e.rel at ed Ta rg e t !== e . delegat eT arg e t  && !e.delegateTarget.cont ai ns(e.related Target)) return t.call(t h is, e) }; n ?   n = t(n)   : i = t(i) }  con st [ o,   r , a] =  S ( e, i,  n ),  l   = x( t) ,  c  = l [a ] || ( l[ a]  =   {}),  h  =  D (c,  r , o ?  i  :  nu l l) ; if (h)  re turn voi d  (h. oneOff  = h.o neO ff  & &  s);  c ons t   d  =  L( r ,  e.re p l ace(y, "")), u = o  ?  functi on  (t ,  e , i )  { retu rn func tion n(s) { cons t  o  =  t . q u erySe l e ct orAll(e); for (let { targ et :  r } = s;  r  &&  r  ! = = this;   r =  r. par entNode)for (let a = o.le ng t h;  a--;)if (o[a]  = == r) r e turn  s.de le ga teTarget = r, n.on eOff && j.off(t, s.ty p e,  e, i ),  i .apply(r, [ s]);  return   null  }  }( t, i, n) : function (t, e )  {  return   function i(n ) {  re tur n  n.delegateTarg e t = t,  i .oneO ff & &  j. off(t, n.type, e),  e.apply(t, [n]) } }( t , i );  u.delegat io nS e le ctor = o  ?  i : null ,  u.o riginalHandl er = r,   u.on e O ff =  s ,   u.u id E v ent = d,  c[d] =   u , t . a ddE v e ntL i s tener (a, u, o )  }  f un c tion I(t,  e,  i, n, s) { const   o  = D(e[i], n, s); o && (t. r e moveEventListener(i, o, Boolean(s)) ,   delete e[i][o.uidEvent])   }  f u nction P(t) { return t = t.replace( w, ""), O[t] | |  t }  c o n st j = { on(t, e,  i , n) { N (t , e, i, n,  !1 ) } , one( t,  e ,  i, n) { N(t, e, i, n, !0)  } ,  off(t, e, i, n) { if (" st r ing"  ! =  type of  e | |  ! t) return; const [s ,  o , r] = S(e, i, n),  a = r !== e, l = x (t ), c =  e. s ta rtsWith("."); if (v o i d  0   !== o) {   i f  (!l | |  !l [ r]) retu rn ; return  void I(t , l, r,   o, s ? i  : null)  }  c  &&  Objec t .keys(l) .f o rEach((i => { !function (t, e, i, n) { const s = e[i] || {}; Object.keys(s).forEach((o => { if (o.includes(n)) { const n  =  s[o ];  I( t,  e, i, n .o riginalHandler,  n .dele gationSel ec t or ) } })) }(t , l, i,  e.slic e (1)) }));  const h = l [ r]  || {};  O bject.keys( h ). forEach ( (i => { const  n  =   i.rep la ce(E, ""); if  ( !a  || e.includes(n)) {  const e = h[i]; I(t, l, r , e.or i ginalHand l er, e.delegationSelecto r) } })) }, trigger(t, e, i ) { if ("string" !=  typeof e || !t) return null;  const n = f(), s = P(e), o = e !== s, r =  k. h as(s);  l et a , l   = !0, c = !0, h =  ! 1 ,  d  =  nul l;  r e turn o && n && (a = n . Event(e, i), n(t). trigger(a), l  =  !a.isPropagationStopped(), c   =  !a . isImmediatePropagationStop pe d(), h = a. isDefaul tP revented ( ) ) , r ?   (d = document.create E vent(" HTMLEve n ts"), d.initEvent ( s, l, !0)) : d = new CustomEvent(e, { bubbles: l, cancelable: !0 }), void 0 !== i && O b ject.keys(i).forEach( ( t => {  Object.definePro p erty(d, t, { get: () = >  i[t]  }) })), h && d.prev e n tDefaul t (),   c  && t.d is p atchEve n t(d), d.defaultPrevented && vo i d  0 !==  a && a.prevent De fault(), d } }, M = new Map , H = { s et( t ,  e, i)  { M.has(t) || M.set(t, new Map );  const n = M.get(t) ; n.has( e) || 0  === n. s ize ? n .s et(e, i) : console.err or(`Bootstrap doesn't allow m ore  t han one instance  p er element. Bound   instan ce: ${A r ray.fro m (n .keys())[0]}.`) }, get: ( t, e) => M.has(t) && M.get(t).get(e ) || nu ll, remove(t, e) { if (!M.has(t)) retur n; cons t  i = M.get(t); i.delete(e), 0 === i.size  && M.delete(t) } }; cla ss  B { constructor(t) { (t  = r(t)) && (t hi s ._element = t, H. s et(this._element, this. constructor.DATA_KEY, th is)) } dispose() {  H.remove(this. _ element, this.constructor . DATA_KEY), j.off(this._ele me n t, this . constructor.EVENT_KEY), Obje ct .getOwnPr op ertyNames ( th is).for Eac h((t  = > { this[t] = nul l  })) } _queueC all ba ck(t, e, i = !0) { b(t, e, i) } static getInst ance(t) {  r etu r n  H.g et(r(t),  this. DATA_KE Y ) } static getOrCreateInstan ce(t, e = {}) { r e turn this.getInst a nce(t)  || new  t his(t, " o bject" == typeof e ? e : null) } static ge t VERSION() { return "5.1.3" } static get   NAME() { throw new Error( ' You have to implement the  st a tic met h od "NAME", for each componen t!') } s tat i c  get DA TA_ K E Y() { return  ` bs.${t his.NA ME} `  }  static  ge t  E VE NT_ KEY() { return `.${t h is.DATA_K E Y} ` }   }  const  R =   ( t, e   =  " hide") => { c o nst i = `click.dismiss${t. EV EN T_KEY}`, s = t.NAME; j. o n(document, i,  `[data-bs-dismiss="${s}"]` ,  (f un c tion (i) { if (["A" , "AREA " ].includes(this.tagN ame) && i.preventDefault(), c(thi s))  retur n; cons t   o = n(this) || this .c lo s est(`.${s}`); t.getOrCreateInstan ce (o )[e]() })) }; class W  ex t ends B { static get NAME() { return  "a lert" } close() { if   (j .tri gger(t his ._eleme n t,  "close.bs.alert").defaultPrevented) ret ur n; this._element.classList.remo ve ( "show " ); const t = thi s._e l e ment.classList.contains(" f ade"); thi s._queueCa llba c k((() => this._ dest r oy Element()), this. _el em en t, t) } _destroyElement() { this._ele ment.remo v e(), j. t rigger(this._element, "clo sed.bs . aler t"),  t his.dispose() } sta tic j QueryI n terface(t) { retur n  t his.each( ( fu nc tion  () { const  e = W .getOrCreate In st a n c e(thi s);   i f ("string" == typeof t)  {  if (void 0 === e[t] || t.startsWith("_") || "constructo r" = == t) th row   n ew TypeError(`No method n am ed "${t}"`); e[t](this) } })) } } R(W,  "cl ose"), g( W);  c on st $ = '[data-bs-toggle="button"]' ;  class z extends  B { stati c  g et NAME ( ) {  retu r n "button" }  tog gl e ()  { this._e lem ent.setAttribute( "a r ia- pressed", this._element. cl assList.to g g le("active"))  } stati c  jQueryI nt e rface ( t) { return this.each((fu nct io n ( )  {  const e = z.g etOrCr eate I n stance(this); "toggle" = = = t &&  e [t ]() }))  }   } fun c tion q(t) { return "t rue "  ===   t  || "false" !==  t &&  (t = = =  Number(t).toString( )  ? Num be r( t) : "" === t || "nu l l" ===  t  ? nu ll : t) }  functio n F(t) { re turn t.re place(/[A- Z]/g, (t => ` -${t.toLowerCase()}`)) } j.on(docu me nt, "click.bs.button.data-api", $, (t =>  { t.preventDefault( ); const e =  t .targ et .close s t( $ ) ; z.getOrCr e a t eInstance (e). toggle()  })) , g(z) ; c onst U  = { set DataA ttr ibute( t,  e ,   i ) { t.set Attribute(`data-bs- ${F(e)}`,  i) }, rem oveDat aAttribute(t, e) {  t.remo veAttribute(`data-b s-${F (e)}`) },  getDat aAttribut es ( t ) { if  ( ! t) retu r n  {}; co n s t e = {} ;  r e turn Objec t. keys(t.data s et ). f ilter((t => t.start sW i th("bs")) ). f orEach((i => { let n = i .replace(/^bs/, "" ) ; n = n.charAt (0 ) .toLowerC ase() + n.s l ice(1 , n.length), e [ n] =  q(t.dataset[i]) })) ,  e },  getDataAttrib u te:  (t, e) => q(t. g etA ttribute(`data-bs - ${F(e )}`)), offset(t)   {  const e = t.getB o un dingClientRe c t(); return { top:  e.top + window.pageYOff s et, left: e.left + window.pageXOf fset } }, posit ion: t => ({ top: t. o ffsetTop, left : t.offsetLeft }) }, V = {  fi nd: (t, e = document.doc u me ntElement) => [].c o ncat(...Element.prototype.que rySelectorAll.call(e, t)) ,  findOne: (t, e = do c ument.do c umentElement) =>  E lement.p r ototyp e .querySelector . call(e, t), child r en: (t, e) => [] .c oncat(...t.child re n).filter(( t  => t. m atches(e))), p a rents(t,   e )  { const i = [];   let  n = t.parentNode; for (; n && n.nodeType === Node.ELE MENT_NODE && 3  ! == n.nodeType;)n.m atches(e) && i.p ush(n), n = n.parentNode; retu rn i }, prev(t ,  e)  {  let i =   t .p reviousElementS i blin g; for (; i;)  {  if (i.matches(e)) return [i]; i  = i.previousE l ementS ibling } ret ur n [] }, next(t, e) {  le t i = t.nextEle me ntSibling; for (; i;) {  if (i.matches( e )) return [i]; i = i.nextElementSibli n g } return [] }, foc u sableChildren(t) { con st e = ["a", "button",  " input " , "textarea", "sele c t", "details" , "[tabindex]",  '[cont e nteditable="true"]'].map((t => `${t}:not ([ ta b index^="-"])`)).jo i n (" ,   ") ; retur n  this.find(e, t).f ilter((t => !c(t) && l(t))) } },  K  = " ca rousel", X =  {  in ter va l: 5e3, keyboard: !0 , slide: !1, pause : "hove r " ,   w r a p:  !0, touch: !0  }, Y = { inter v al: "(number| b oolean)" ,   keybo ard: "boolean", slide: "(boolean|strin g)", pause:  " (string| b o o le an )",  wr ap:   " boolean", touc h : "bool e an" }, Q = "next", G = "pre v" ,  Z  = " left",  J = "ri g h t ", tt = { ArrowLe ft: J, ArrowRigh t :  Z  } , et = "slid. b s . c a ro u sel", it = "active",   nt = ".active.carouse l- item"; class st ext ends B { constructor(t ,  e)  { super(t), this._ items =  nu ll, this._interval  =  null, this._activeE lement = null, this._isPa us ed  = !1, this._isS liding = !1, this.t ouchTimeout = null, this. to uc hStartX = 0, this .touchDeltaX = 0,  th is._config = this._g et Config(e), this._indicatorsEle m ent = V.findOne(".carouse l -indica t o rs ", this._element),  t his._t ouc hSupported =  "o ntouchs tar t" in document. d o c um e ntEl e ment || navigato r .maxTouch P oints > 0, this._p oi nterEvent = Boole a n(window.PointerEvent ),   t h is . _addEventListene r s() } sta ti c get Default()  {   r e t urn X } static get N A ME() { return K  }  n e x t( )  { t hi s._slide(Q) } nex t WhenVisib l e() { !document.hi dden && l(this._elem ent) &&  th is.next() } prev()  {  this._slide(G ) } pause(t) { t  ||  (this._isPaused = !0), V.findOn e(".carousel-item - next, .carous el -item-prev", th is. _ element) && (s(this._el em ent), this.cycle(!0)), clear Interval(this._interval),  t h is._int erval = null } cycle(t)  {  t  || (this._isPaused =  !1) , this._interval & &  (clearInterval(this ._interval), this._interva l  =  null),  this._config && thi s._config.interval && !t hi s. _isPaus ed && (this._updateInterval(), this._interval   = setInterval((docum ent.visibilityState ? thi s. ne xtWhenV isible : this.next) .bind(this), this._confi g. in terval) ) } to(t) { this._a ctiveElement = V.findOn e( nt , this. _ element); c o ns t e = this._getItemIndex(this._activeEleme nt); if  (t > t h is._items. l en gth - 1 || t < 0) re turn; if (this. _ isSliding) retur n  void j.one(this._ e l em ent, et, (()   => this.to(t))); if (e = == t) return  t his .pause(), void this.cy c le(); const i = t  >  e  ? Q :  G ;  th is ._slide(i, this._item s[ t] ) } _getConfig(t)  {  return t = { ...X, . .. U .getDat a Attributes(this._eleme n t ), ..."object" == typeof t ? t :  {} }, a(K, t, Y ), t } _handleSwipe() { const t  = Math.abs(this.tou c hDeltaX); if ( t  <= 40) ret ur n; co ns t e   =  t  / this.touchDeltaX; this.tou c hD eltaX = 0, e && this._sli d e(e > 0   ? J : Z) } _addEvent Listeners() { this._confi g.keyboard && j.on(this ._element, "keydown.bs.carousel",  (t => t h is._keydown(t))), "hover"  === this._config.pause &&  (j .on(th i s. _ e lement, " mousee nter.bs.carousel", (t => this.pause(t))), j.on(this._el eme nt,  "mouseleave.bs.carous e l", (t => this.cycle(t) ))), this._config.touch && this._ touchSup porte d   & & this._addTouchE v entList e ners() } _addTouchE ve ntListeners()  { const t = t  =>  thi s._poin terEven t  && ("pen" === t.pointerType || "touch" === t.point erTy p e ), e = e => { t(e) ? this.tou c hStartX = e.clientX : this._ po interEvent || (this.to uchStartX = e.touches [ 0] . clientX) }, i = t =>  {  this.touchDeltaX = t.touche s  && t.touches.length >   1 ? 0 : t .t o uches[0 ] .clientX - this.touchStart X   }, n = e => {  t(e) && (this. t o uchDeltaX = e.clientX  -   t hi s.touchStartX), this._h and l e Swipe(), "hover" === t h i s._config.pause && (this . p a use () ,   t h is.touchTimeout && cl e arTimeout(this.touch T i m e out), this.touchTime o ut = setTimeout((t =>   t his.cycle(t)), 500 + this. _c on fi g.interval)) }; V.find(". carousel-it em img", this._e l emen t) .forEach((t => {  j.on(t,  " dragstart.bs.carousel", (t  => t.preventDefault( ))) })) ,  thi s. _po interEv ent ? (j.on(thi s ._e l em ent, "pointer down.bs.carousel", (t => e(t))), j. on(this._element, " p oi nterup. b s. ca r ousel", (t => n(t))), th is. _ element.classL is t.add("poi nt er-ev en t") )  :  ( j. on(this._element, "touchstart.bs.carousel",   (t => e(t))), j.on( this. _element, "touchmov e.bs.carousel", (t  => i(t) ) ),  j . on(this._element, "to uch end.bs.carousel", (t  => n(t)))) } _keydown (t ) {  if (/input|tex t are a/i.test(t.ta rg et .tagName)) return; con st  e  =  tt[t.key]; e && (t.preventD efault(), this._slid e(e)) } _getIte m Ind ex(t )  {  return this . _items = t && t.pare n tNode  ? V .find(".carous e l-i t e m",   t . p a r e ntN o d e )   :   [ ], this._items.index O f(t) }  _g etItemByOrder( t , e )   { c o n s t   i   = t   = = =   Q ;   return v(this._items, e, i,  t h is._con f ig.wrap) } _triggerSlideE ven t(t ,  e) { co n s t  i  = this. _g etItemIn de x( t ) , n =  thi s._ getItem I ndex(V.f in dOne(nt,   t h is._elem en t)); retu rn  j.trigge r(this._ element , "slide. bs .carousel " ,  { relat edT arget : t, direction: e, from: n, to: i }) } _setAct iveInd i catorElement(t)  {  if (t hi s._indicato rsElement)   { const e = V.findOne(".a c tive", this._indicatorsEle me n t); e.classList.remove(it) ,  e.r e moveAttribute("aria-current") ;  const  i  = V.fin d( "[d at a-bs-target]", this._indicatorsEle ment);  for (le t   e = 0; e < i.length; e++)i f (Number.parseInt(i[e].getA tt r i bute("data-bs-slide-to"), 10) === this . _g etItemIndex ( t))  { i[e].classList.add(it ),  i [e ].setAttribute("aria-cur rent", "true"); br e a k } } } _updat eInterval() { const t = this. _activeElement || V.findOne(nt, this._ element); if (!t) return ; const e =  Number.parseInt(t.getAttribu te( "d a ta-bs-i n terval"), 10); e ? (this._config.def aul tInter v al   =  this._co n f ig .defaultInterval || this._conf ig.interval, this._co nfig .inter val = e)   : this._con fi g . interva l =  this._ conf ig .d e f aultInt erval || t his._co nfig.interval }  _s li d e(t, e)  {   const i = t hi s ._directionTo Or d er(t), n = V .f i ndOne(nt, this._element), s =  t h is._getItemIndex(n), o = e ||  this._getItemByOrd e r(i, n), r = t hi s ._getItem Index(o), a = Boolean ( thi s._interval) ,  l = i === Q, c = l  ? "carousel-item- s tar t" : "c a rousel-item -en d", h  =  l   ?  "carouse l - it em-n e xt" : " c arous e l -item - p rev", d = this._ord er T oDi rection(i); if ( o &&  o. c la ssList.c on tains(it)) retu r n  void (this._isSliding = !1) ;  if (this._isSliding) retur n; if (this._trigge rS lideEvent(o, d).defaultPrevented) return; if (!n | | !o) return; thi s._isSliding = !0,  a  && this.pause ( ), this._setActiveIn d icatorEle m ent(o), this._act i veElement   = o; con s t f = () => { j . trigger(thi s ._element,  e t, { r e la tedTarget: o, directio n:  d, from: s, to:  r }) } ; if ( t h is. _e lement.classList.cont a ins("sl i de")) { o. classList.add(h), u(o ) ,  n.classList.add(c), o.classList.add(c); const  t = () => { o.classList.remov e( c, h), o.classLi s t.add(i t ), n.classList.remove(it,  h,  c), this. _ isSlidi n g = !1, s et T ime out( f,  0 )   } ; this._queueCall b ack(t ,  n , !0) } else n.clas sList. r em ove(it), o.classList.add( it), this._isSliding = !1, f(); a &&  this.cy cle() } _dir ec t i onT o Or der(t) { return [J, Z].in c ludes(t )  ? m() ? t  = ==  Z ? G :  Q : t === Z ?  Q :  G :  t } _or d erToDirection(t) { re turn [Q, G].includes(t) ? m() ? t = == G ? Z : J : t === G ? J : Z :  t } static carouselIn t er face(t, e) { const i = st.getOrCreateInstance(t, e ); l et { _config: n } = i ;  "o bject"  = = typeof e && (n = { ...n,  . ..e }); const  s = "string" == typeof  e   ? e : n.slide; if ("n u mbe r" == typeof e) i.to(e); else if (" string" == typeof s) { if (void  0 = == i[s]) throw new Typ e Err or(`No method named "${s }"`); i[s]() } else  n.i nterval && n.r ide  && (i.pause(), i.cycle ( )) } static jQueryInter f ace(t)   {  return this.each((func ti on () { st.carous elInter fa ce(this, t) })) } static  dataApiClickHandler(t) { const e = n( this);  if (!e  | | !e.classList.contai ns("carousel")) return ;  const i = { ...U.getDataAttributes(e), ...U.get DataAttributes(th is) }, s = this.getAttribute("da ta-bs-slide-to"); s && (i.interval  = ! 1), st. c arouselInterface(e, i), s  &&  st.get I ns t a nc e(e) . to(s),  t .preventDefault() } }  j . on(do c um ent, "click.bs.ca ro usel.data-api", "[data-bs-slide], [ dat a -bs-slide-to]", st.da t aAp iClickHandler), j.on(w i ndo w, "load.bs.carousel.da ta - api", (() => { const  t  =  V.find('[data-bs-ride="carousel"]') ; for (let e = 0, i = t.length;  e < i; e++)st.carouselIn terface(t[e], st.getI nst ance(t[e])) }) ),  g (st); cons t  ot = "collaps e ", rt = { toggle: !0, parent: n u ll }, at = {  t oggle:  " b o olean" , parent: "(null|element)" }, lt = "sh ow",  ct = "co l lapse", ht = "coll apsing",   dt = "collap sed",  u t =  " : scope .collapse   .collapse", ft = '[data-bs-toggle="collapse"]'; class pt exten d s B { c o nstructo r (t, e) { super(t), th i s. _isTransitioning = !1,  this._ config  =  this._get Config(e), this._trig gerArray =  []; const n = V.find(ft); for  ( let t = 0, e = n.length; t  <  e ; t++)  {  cons t  e  = n[t], s = i(e), o = V.find(s).fi lter((t => t ===  thi s ._element)); null !== s && o .l e ngth &&  (t his._selecto r  =   s , this._triggerArray.p u sh(e)) } this._initi alizeChildren(), this._config.p ar ent   || this._addAriaAndCollap s edClass(this._triggerArray ,  t his._is S how n()), th is ._config .t oggle && this.toggl e( ) } stati c  get  Defaul t () { return rt } static get  NAM E( ) { retur n  ot } togg l e( ) { thi s._ isSho wn() ? this.hide() : this.show() } show() { if  (this . _is T r ansitioning ||  this._isShown()) return; let  t,  e = [];  if  ( this ._c onfig.parent) {  co nst t = V.find(u t,  th is. _config.parent); e = V.fi nd (".collapse.show, . collaps e .collaps ing", this._config.p ar e nt).filter((e => !t.inclu d es(e)))  }  const i =  V.f indO ne(thi s._sel e ctor);  i f  (e.lengt h)   { const  n  =  e.find (( t  => i ! ==   t));  if  (t  = n  ?   pt.getIn st a nce(n)  :   null, t && t._isTr an s itioning) r et u rn } if ( j. t rigger(this. _e l ement, "show.bs.col lap se " ).defaultPrevented )  re t urn ;   e.f o rEac h(( e =>  {   i !== e && pt .getOrCreateInstance(e , {  t o ggle: !1 }).hide(),   t  ||   H.s e t (e,   "bs. col laps e" ,  null) })); c on s t n = t hi s ._getDimensi on ( ); this._elem en t .classL is t .remove(ct),  t h is._element.cl as s List.add (h t ), this._elem en t .sty le[ n]  = 0 , t his ._a ddA riaA ndCollapsedCla s s(this._ t riggerArray ,  !0), this._isTran s itio n ing = !0; cons t  s  = `s cr ol l${n[0].toUppe rC ase() + n.slice(1) }`;  this._queueC a llbac k ((() => { this._ isTransi ti oning = !1, t hi s._ele m ent.clas s List.remove(ht ) , this._element.classList.add(ct,  l t), this._element.st y le[n] = "", j. t rigger(this._element, "shown.bs.colla ps e") }), this._element, ! 0 ), this._eleme n t.styl e[n] = `${t hi s._element[s]}px`  }  hide() { if (this._isTransiti on ing || !this._isShown())   return;  i f  (j.t rigger(this._e lement,  "hi de.bs. collapse "). defaultP rev e nted)   return;  const t = this._getDimension(); this._ele men t .styl e [t] = `${th is ._e l e ment.getBoundin gC lie n t Rect()[t]}px`,  u(th is ._ele me nt), this._element.clas sLi st.add(ht), this._element.classL ist . remov e (ct,  lt );  c o nst e = this._trigge r Array.length; for  ( let   t  =   0;  t <  e;  t ++) { c onst e =  th i s._tr i ggerArra y [ t ], i =  n (e); i &&  !this._isShown(i)  && th is._ addA riaA ndColla pse dC lass([ e ], !1) }  this._isTr an sitioning  =  !0 , this._element.style[t] = "", this._queueCal lback((()  => { thi s ._ isTransitioning  =  !1, this._element.classList.remove(ht ), this._ element. cl a ssList.add(ct), j.trigger(this._element,  "hi d den.b s .collapse") }) ,   this._element,  !0 ) }   _ isShown(t = this._element) { return t. c lassList.co n tains(lt) } _getConfig (t)  {   return (t =   { . . .rt , .. .U.ge tD ataAt tr ibutes(this._element),  ... t }).toggle = Boolean(t.toggle),  t. p arent = r(t.parent),  a(o t,  t ,  at), t }  _getDimension() {  r eturn this._el e ment.classList.contain s ("collapse-hor iz o ntal" )  ? "width" : "height" } _i nitial i zeChil dren()  {  i f (!thi s._confi g .p aren t) re t ur n; con st t =  V .f ind(ut,  this._c o nf ig.pa rent);   V. fi nd(ft,   th is ._con f i g . parent).filter ( (e =>   !t.inc l u des(e))).forEa c h ((t => { const  e = n(t); e && this._ad d Ar ia A nd Co l lapsedCla ss([t], this._isS h ow n( e ))  } ) ) } _addAr i aA ndCollapsedCl as s(t, e) { t. length  & & t.for E a c h((t => { e ?  t. c lassL i st.remove(dt)  :  t.classList.add (d t), t.setAttrib ute("a ria -e xp an ded",  e ) }))   }  st a ti c  jQ ueryInterface(t)  { ret urn   t his.each((fu nc tion ( )  { co nst   e = {} ;  " string" == typ e of t && /show|hide/.test(t) && ( e .toggle = !1);   const  i = pt.ge tOrCr eateInstance(this, e );   i f ("string" ==   typeof  t) { i f  (void 0 === i[ t ]) throw ne w  TypeError(`No method named "${t} " `); i[t]() } } ) ) } }  j.on(d ocu ment,   " c lick.bs.collap se .data-api",  ft , (fun c tion ( t ) { ( "A " ===   t.target.tagNa m e || t.deleg at eTarget  &&  "A" === t.del e gateTarget.tag N ame)   && t.preventDe f aul t(); c o nst e  =   i(this ) ;  V.fin d( e).forEa ch( (t => { pt.getOrC r eateIn stance(t ,  { toggl e:  !1 }) .t oggle( ) } )) }) ),  g(pt);  var  mt = "top", gt   =   " bo ttom", _ t =   "righ t ",  bt  = "left", vt = "auto", yt = [mt, gt, _t, bt], wt = " st art ",  Et = "end", At = "clippingParents", Tt  =  "vie wp ort", O t =  "popper", Ct =  "reference" , k t = yt . reduce ((fun ct ion (t,  e) { return t.concat([ e  +  " -" +  w t, e +  " -" + Et ])  }), []), Lt  =  [].co nca t(yt, [vt]).r ed uce((fu nct ion (t, e )  {  ret urn t.concat( [e, e + "-" + wt, e + "-" + Et]) }),  [ ] ),  xt = "b efo reRead", Dt  =  " re ad", St  =  "after Rea d", Nt =  "beforeMa i n ", It = "mai n ", Pt = "af terM ai n " , jt = "before W rite",  Mt = " write", Ht = "afterW ri t e ",  B t =   [xt, D t , St, Nt,  I t , Pt, jt,  M t , Ht]; func tion Rt(t) { r et ur n  t ? (t.node Name  ||  " ").toLowerCase ( ) : null } function Wt(t )  { i f  (null  ==  t) ret ur n win d ow ;  i f ("[object Wi nd o w]" !== t.toString()) { v ar  e  =  t.ownerDoc u me n t;  ret u rn e &&  e . defau ltView | | window  }  return  t } fu nct ion $t(t ) {   return   t  instanc e o f Wt(t) . E lement ||  t   instanceof Elemen t   } function zt(t) { return t in s t anceof Wt(t).HTM L E lement   | | t  instanceof HTM LE l e ment } f u nction q t( t)  {  r e turn  " undefine d"  !=   typeof ShadowRoot  &&  (t in st a nceof Wt(t ). ShadowRo o t || t instanceof S hadowRoo t ) } const  Ft = { name : " a pp l y S tyles ", e nabled: !0,  pha s e : "wri t e ",  fn:   f un c tio n   (t)  {  v a r  e  =  t . state; Object.keys(e . elements).forEach((f u ncti o n (t) { var i = e. s t yles [ t] || {}, n = e.attri b u tes[t]   | |   {},  s  =   e.elements[t];  z t ( s) && Rt(s) & &  ( O bj e c t . a s s i gn ( s .styl e ,   i ), O b ject. k e y s ( n ).fo r E a ch ( ( funct io n ( t )  {  var e = n[t]; !1  = ==  e  ? s.r e mo veAttribute(t)   :   s. se t At tribute (t, !0 = ==  e  ? ""   : e) })) )   })) }, effect: fun c t ion (t ) {   v ar e = t.state, i = {   po pper :  {  p osition:  e. options. st ra t egy, left: "0", top: "0", margin: "0 "  }, arrow: { position:  " ab solute" }, refere n ce :  {} }; ret urn Object.assign( e.elements.popper .style, i.popper),  e. styles = i, e. e lements.arrow && Objec t .assig n ( e.el ements. arrow. style,  i.arrow ), func tion  () { O bj ect.keys(e.ele m ents). f o rEach((fu n c tion (t) { va r   n = e.elemen t s [t], s = e.a t t ributes[t]   | | {}, o = O b j ect.keys(e.styles. h a sOwnPropert y ( t) ? e.styles[t ]   :  i[t ] ) .reduce( (fu n ction   (t,  e )  { r e t urn t[e] = "", t }), {} );  z t(n) & &  R t(n) &&   (O b je ct .a ss ign(n.s t yl e ,  o) ,   Obje c t.keys(s). fo rEach((f u ncti o n  ( t ) {  n . remove Att r i b u te ( t ) }) ) )  })) }  },   r e q ui r e s: ["computeStyles"] } ;   function Ut(t) { retur n   t.s p l it( " - ")[0] }  f unc t ion V t (t, e)   {  var i = t.getB o u ndingClientRec t ();  retu rn  { width : i .wid t h / 1, height:  i. height / 1 , t o p:  i . top / 1, right:   i .right / 1, bot t o m:   i.b ot to m  / 1 ,  le f t:  i. le f t /  1,  x :  i .le f t  / 1,   y: i.top  /  1   }   }  fun c tio n  Kt (t ) {  v ar   e =  V t( t ),  i =  t .o f fse t Wi dth,   n = t.of f se t H e i ght ;  retur n   Math.abs(e.widt h - i) <=   1  & &  (i =  e.width ) , Math.abs(e.heig ht  -  n ) <= 1   & &  (n   = e .hei g h t ),  {  x:  t.offsetLe f t, y: t.offsetTop,  wi dt h:   i , height: n  }   }  funct i o n  Xt(t ,  e) { var i =  e . g etRoot N o d e && e.ge tRo o tNode(); if (t.co nt ain s (e)) r e t u r n  !0;   if  (i & &   q t ( i))  {  va r n = e; do   { i f ( n  && t.is S a meNod e(n)) return !0;  n = n.p are ntNode  || n.host } w hil e (n) }  ret u rn !1   } functi o n  Yt(t) { r e t urn Wt(t).getCompu t e dStyle (t)   }  fu n c tion Qt(t)  {   return  [" t ab le " ,  "td", "th"].in d e xOf(Rt (t) )  > =  0   }  function  Gt(t) { return ( ($t(t) ? t .ownerDocument :  t.docu ment) || window.do cument).doc umentElement }  function Zt(t) {   re turn  " html" === Rt(t) ? t : t.assig ne dSlot || t.paren t Node || (qt(t) ?  t.host : null) | | Gt(t) } function J t( t ) { retu rn zt(t) && "fixed" !== Yt(t). position  ? t.offsetParent :  null } fu nc tion te(t) {  f or (va r e  =  Wt(t), i = Jt(t); i & &  Qt(i) && "stati c " === Yt(i).posit ion;)i = Jt(i);  return i && ("html"  = = = Rt(i)  || "body" === Rt(i) &&  "static"  === Yt(i). position)  ?  e : i || func t ion (t ) { var e = -1 !==  n avigator.userAgen t.toLowerCase().inde x Of("firefox"); if (-1 != = navigator .u se rAgen t. in dexOf( " T rident")  & &  zt(t) &&   " fixed " === Yt(t).posit ion) ret urn  null;  for (va r i  = Zt(t) ;  z t( i) && [ "html",  "bo d y"].i n dexOf(Rt ( i )) < 0;) {  v a r n = Yt(i ) ;  if ("non e "  !== n .tr a ns fo r m  || "none "   !== n. per s pe ct i v e || "paint" === n.con t a in || -1 !== ["transform", "perspect ive"].indexOf(n.willChan ge) || e  & & "filter" === n.wi llC h ange || e && n.filter && "no ne" !== n .fi lter )  r eturn i; i = i.parentNode }  return nu ll } (t) || e  }   f un ction ee(t) { retur n [ " top", "bottom"].indexOf(t) >= 0  ? "x" :  "y"  } v a r  ie = Math.max, ne = Math.min, s e = Math. rou n d;  func ti on  oe(t,   e , i)  { return  ie(t,  ne(e,  i)) } f unctio n re (t) { re tu rn Object.assi g n({}, { top: 0, right: 0, bottom: 0, left:  0 }, t)  } f u nction ae(t,  e)   { retu r n  e.red uce((f unct ion (e,  i ) { return e[i ]  = t, e }), {}) } const le = {  name: "a rro w ", enabled:  !0,   phase: "main",   fn: f u nction  (t) {   var e, i =  t.state, n = t .name, s =  t.options, o   =  i.elements.ar r ow, r = i.modifiersDa t a.popperOffsets,   a = Ut(i.place m ent),   l = ee ( a ), c = [bt,   _ t].indexOf(a )   >= 0 ? "heig ht" :  "width"; if (o && r) { var h = func t i o n  ( t, e) { return   re("nu mber" !=  typeof  (t = "function" == typeof  t  ?   t(Object.assign({},  e .rect s,  { pl a c e ment: e.p l acement })) :  t)   ? t :  ae(t,  yt) )  } (s . padd ing,  i ), d =   K t (o) , u =  " y"   === l ? mt : bt,   f = "y "  === l ?   g t : _t ,   p   = i.rects.reference[c] + i. re cts .refe r e n ce[ l ]  -   r[l] - i.rec ts.poppe r [ c ], m = r[l] - i.rec t s.reference[l] ,  g = te(o), _ = g ? "y"  == =  l ?  g.cl ient Heig ht ||  0 :   g.client Width | | 0   : 0, b =  p   / 2 - m / 2, v  =   h[u], y  = _  -   d[c] - h[f] , w   = _ /   2 - d[ c ]  / 2 +   b , E = oe(v, w, y) ,   A = l; i.modif i e rsData[n] = ((e   =  { } ) [A ] = E, e .c en t erOffset   =  E - w, e ) } }, effect: function (t) { var e = t.state, i = t.optio ns .e l ement, n = vo i d  0 === i ? "[d a ta-pop pe r-arrow ]"  :   i ; null  ! =   n &&  ( "stri n g" != ty peo f  n ||   (n = e .elements.po p per.q u erySelector( n))) & &  Xt(e. e lements.poppe r, n) &&   (e.el e ments.arrow = n ) }, re q uires:   ["popperOffset s"], re q uiresIfExists:  ["preve n tOverflow"] };  fun c tion ce (t)   { retu r n t. s plit("-")[1 ] }   var he   =  { top :   "auto" ,   righ t:  " a uto", bottom: "a u to", l e ft: "au t o " }; function de( t) { var e, i  =   t.popper, n =   t. p o pperRect, s =   t.p l a cement, o = t.vari ation, r = t.of f s ets, a = t.pos i ti o n , l = t.gpuAcc e ler a t ion, c = t.ad a ptive,   h  = t.roundOff sets,  d = ! 0 = == h  ?  function (t )  {  va r e = t.x, i = t. y ,  n = window.d e vi c ePi x elRati o  || 1; r et ur n  {  x :  se(se(e  *  n) / n) || 0,   y: se( s e (i * n) / n)   | | 0 } }(r)   :  "function"  = =   t ypeof   h ? h ( r )   : r,  u  = d. x ,  f  =  void 0   = = = u ? 0   :  u ,  p  =  d.y, m  =   v oid 0 == =  p  ? 0 :  p,   g = r.ha s O w nP ro pe rty ( "x"), _  =  r.hasO wnProper t y ( "y ") ,  b =   bt, v =  mt , y =  window;  i f   (c ) {   var w =  te ( i) , E =  "clientH e i g ht ",  A  = "clie nt W id th"; w  === Wt( i )   &&  "st at ic"   !== Yt ( w   = Gt( i )).po si tion  &&  " a bsolu t e"  ===   a  && (E =   "scrollH eight" , A   = "scrol lWid t h"),   w = w ,   s  !==   mt  && (s  !== bt & & s  ! == _ t  || o   ! = = Et )  | |   (v = gt,   m -= w[E] - n. he i ght, m  *=   l  ?  1  : - 1), s   != =   bt && (s !==   m t && s  != =   gt || o !==   Et )   || (b = _t,   f  -= w[ A]  -   n. w id t h , f *= l ? 1 :  - 1 ) } va r T ,   O  =  O b j ect.assign({ posi t i on: a  },  c   &&   he ) ;  return l ? Ob j e ct.ass ign ( {} ,  O ,  ((T = {}) [ v ] = _  ? " 0 "   :  " " ,  T[b] = g ?  " 0" : "",   T . trans form  =   ( y.d ev i ce P ixe l R atio || 1) <= 1   ?  "translate( "   +  f  +   "px, " +  m  +  "p x )" :  " translate3d(" + f  +  " p x, " + m  +  " px, 0 ) ", T)) : O b j ect.assign({ }, O, ((e = {})[v] = _ ? m + "px "  :  " ", e[ b ] = g   ?  f + "px" : " " , e.transform = "" , e ) ) } const ue  =  { na me :  "compu teS tyles ",  e na bled :  !0, phase: " b e foreWrite",  fn: f u n ction   ( t) { var e = t.sta te,  i   = t.o p tions , n  = i.gpuAcce l eration,  s = voi d 0 ===   n || n, o =  i.adapti ve, r =  v oid 0 === o  || o, a =  i.roun d Offsets, l  = void  0  == = a | | a,  c = { placeme n t: Ut(e . placeme nt), var i ation: c e (e.pla cem e nt), po ppe r : e.el e ments.p o p p er, popperRect:  e. rects.popper, gpuAccel er ati o n : s }; null != e.modifier s D ata. popperOffs et s && (e. st yles.popp er = Object .assign({} ,  e. s t yles.popper, de(Obje ct .ass i g n ({} ,  c ,   {  o f f sets : e.m o difie r sData. popperO ffsets,  p osition:   e.options .stra tegy,  a daptiv e : r, ro undOff sets: l   })))),  n ull !=  e. m o difiersData.arrow && (e .s ty les .a rr ow   = Obj e ct.as sign({}, e.styles.arrow, de(Obje ct. a ssign ( {},  c, { offsets:  e. m o d i fie r s Data .arrow, positi on :   "ab s olut e",  ad apti v e : ! 1 , roundO f fsets: l })))) ,  e .attri but e s. po p per  = Obj e ct . a ssign({}, e. a t tributes.po p p er, { "data-pop p e r-placemen t " : e.placement })  } ,  data: {} }; var fe = {  p a ssive:  !0   } ;  c on s t  pe =  {   n a m e :  " eventListeners", en abl e d: !0, phase : " w rit e ",  f n : function () { },  ef f ect: function (t) {  v a r e  =  t. state, i  =  t . ins tance ,  n = t.options, s  = n .s c roll, o = v o id 0  = == s || s,  r  = n.resi ze , a = void 0  == = r || r ,  l = Wt(e. e lem ents .popper), c = [].concat(e.scrollPare nts .r e ference, e. s crol lPa r ents.pop p e r); r eturn o  && c.fo rEa ch((fu nction  (t)  { t.add Eve n tList e ner("scr o l l", i.upda t e , fe) } )) , a && l.addEventListener(" r esi ze", i . update, fe) ,   functi on  ( )  {  o   && c.forEa c h ((func tio n  ( t)   {  t.removeEventListene r ( "scroll",  i . update, fe)   } )), a && l.remo v e EventListener( " r esize", i.update,   f e) } } , d a ta :  { }  }; var me = { left: "ri g h t", right: "left", b o t tom: " t o p ",  t op:   "b o t tom" };  fun c ti on ge( t)  { r eturn  t.r eplac e (/left |right |bottom |t op/g,  (fun c tion (t)  {   return me[t] })) } var _e = {  sta rt :  "end", end: "start"  };  fu n ction   be(t) { re tu rn t.repl ac e(/start|end/ g,  (functi on  (t) { return _ e[ t] })) } function ve(t )  {   va r e  = W t ( t); return { scrol l L eft: e.pageXOff s e t, scrol l T op:   e .page Y O ff s e t } } fun ctio n  ye(t )  { re t u rn Vt( G t (t)). lef t +   v e(t) .scrollLeft }  fu nc t i o n  we(t)  {  var e =  Y t (t),  i  = e.overf lo w, n = e. ov erflowX, s =  e. overflowY; r et urn /aut o |sc r o l l | o ve r la y | h id d en/ .tes t (i +  s  +   n) } fu nctio n  Ee(t)   {  re tu rn  [ "html", "bo dy ",  " #d ocument"].i nd ex Of(R t( t))  >= 0 ? t.ownerDo cum e nt.body  : zt ( t )  & &   we( t) ?  t  : Ee(Zt (t ) )  } f unc tion A e (t, e) {  va r  i; v o id 0 === e && (e  =  [ ]); v a r n = Ee( t) , s  = n === (null ==  (i = t.ownerDocum ent )  ? void  0 :  i.b od y),  o = Wt( n ),  r = s  ?  [ o ] . c o nc a t ( o. visualV iew port  || [] , we(n) ? n  :  [ ])  : n, a = e.concat(r); re t urn  s ? a : a. c on cat(Ae( Z t(r ) ))  } function Te(t)  { return O bject . assign ({ } ,  t, { left: t.x ,  to p : t.y, right:  t. x  +  t . w id th ,  b ott o m: t .y +  t .height  } ) }  functi on Oe(t ,  e) { r e turn  e ===  Tt ? Te( f unction  ( t) {  var  e = Wt ( t), i =   Gt( t ) , n = e.visual V iewpor t, s  =  i.c lientWidth, o = i. cli e ntHeight, r  =   0,  a  = 0; re t u rn n  && (s =  n.width , o  = n.h eight,  /^((?!chrome|andr oid).)*safari/i.test (na vigator. use r Agent )  || (r =   n .offset L e ft, a = n.offsetTo p ) ), { width: s,  h e ight: o, x: r + ye(t), y: a } }( t ) ) : z t (e) ? function  (t) { var e  =  V t (t);  r eturn e.top  =  e.t o p  + t. cli e n tTop,  e .le f t  = e.l e f t + t. clientLeft, e.bott o m  = e.top + t.clientHeight ,  e.right = e.left + t .c lientWidth, e.widt h  = t.clientWidth,  e .h eight = t.clientHei g ht, e.x = e.left,  e.y = e.top, e }(e)   : Te(function (t) { var e, i =  Gt (t), n = ve(t), s = nu l l  = =  (e   =  t.ow nerDocume nt) ? vo id  0 : e. body, o  = ie(i.s crollWidth, i.clie ntW idth, s  ? s . scrol l Width :  0 ,  s ? s.cli e n tWidth  :   0), r = i e ( i.scro llH e i ght ,  i .c l i entHeight, s ? s.sc rol lH e ight : 0, s   ? s.clie ntH ei gh t  : 0) ,  a = - n . scro llLeft + ye(t) ,  l   =  - n. s c rollTop; r et urn "rtl "  === Yt(s || i).dir ec t ion && (a  + = i e (i . c lient W i dth,  s ? s.cl i e nt Wi d t h  :  0)   -  o),  { width: o, he ig h t :  r ,  x:   a ,   y:  l  }   } (Gt( t))) } f unc t ion  Ce( t )  { var e, i = t . r efer e n ce,  n =  t. element, s = t.placement, o =  s  ? Ut(s) : null, r = s ? ce(s) :  n ul l, a = i.x + i.width / 2 - n.wi dt h /  2, l = i.y + i.he i g h t  /  2   - n.h eight / 2; switc h (o) {  cas e mt:  e = { x : a , y: i.y  -  n .heig h t }; bre a k ; case  gt: e = { x: a, y:   i.y  + i.height  }; break; case _t : e = {  x: i.x + i.widt h, y: l } ; break; ca se bt: e =  { x: i.x -  n .w idth,  y :  l  } ;  brea k; default: e = {  x: i.x,  y:  i.y }  }var c  = o  ? ee(o)  :  n ull;  i f (null  ! =  c) { var  h   = "y" = = =  c ? "heigh t "  : "wi dth " ;  sw i t ch (r) { c a s e wt:  e[c ]  =  e [ c ] - (i[h] /   2  - n[h] / 2); b r e ak; case Et: e [ c ] = e[c] +   ( i[h] / 2  -   n[h] /  2)   }  }  r e turn e } functi o n  ke(t,  e)   {   v oi d   0 ===   e && (e =  { }); var i = e ,  n = i.pl ac ement, s = v o id  0   === n ? t.placem e n t : n, o = i.bou n d ary ,   r = vo i d  0  ===   o  ?  A t :  o ,  a = i.rootBoundary, l = void  0   === a ? Tt : a, c  =   i.elementContex t ,  h = void  0  === c ?  O t : c, d = i.altBou ndary, u   = void 0 ! == d && d,  f =   i. p a d di ng ,  p  =  v oid   0  == =  f  ?  0 :  f , m  =  r e (" n umb e r " ! = t y p eo f  p  ?   p :  ae ( p , yt)),  g  = h ===   O t ? C t   : Ot ,  _ =  t . rect s .popp e r ,   b = t . e l em e n t s[u  ?   g :  h ], v  =   f unc ti o n (t,   e, i)  {   var n = "clipping P a r en t s " ===   e  ? fun ct ion (t)   {  v a r e = Ae(Zt(t)), i = ["absolute", " f ixed"].indexOf(Yt(t).position) >= 0 && zt(t )   ? te (t ) : t;  r eturn $ t( i) ?  e .f i l ter(( f u nctio n   (t) {  retu rn $t( t )   & & Xt ( t ,   i )   & &   " b o d y "   != =   R t (t) } ) )   :   [ ]   } ( t )   :   [ ] .c o n cat(e), s = [].c on cat(n, [i]), o = s[0] ,   r   = s .re d u ce((functio n  ( e , i) { var n  =   O e( t ,  i); return e.top = ie ( n.top, e.top), e.right = ne(n.right, e . ri g h t),  e . b o t to m   = ne ( n . bo tt om,   e.bot t om),   e.lef t  =  i e( n . left,  e . lef t),  e  } ), O e ( t ,   o) );  r eturn   r.w idt h   =  r .ri g h t -  r. l e ft ,  r. h e ight  =   r . botto m  -   r .top,  r . x =  r .left ,  r .y  =   r .top,  r  } ($t( b) ?   b :  b.c o nt e x t E lement || Gt(t.ele m e n ts .popper), r, l),  y = Vt(t.e le ments.referenc e) ,  w  = Ce( { r e fe re n ce:  y, el e ment:  _, st ra tegy: "a bso l ute",   placement: s }), E = Te(Ob ject.ass ign({}, _, w)) , A = h = == Ot ? E : y,  T =  { top:  v . t op - A . t op + m . t o p, bottom:  A. bottom - v . bo t t o m  +  m. b ot tom, l ef t:  v .l eft  -  A.left  + m .left ,  right:  A .r i gh t  -  v. right  +  m.ri g h t }, O = t. mo d ifiersData.off set; if (h  === Ot &&  O )  { var  C = O [ s];   Object.k ey s(T).forEach( (fu nc tion (t) { v a r  e  = [ _ t, gt].i n de xOf(t)   >= 0 ? 1 : - 1 , i  =  [mt,  g t].indexOf( t ) >=  0 ? " y" : "x" ; T[t]  += C[i]  *   e })) } return   T } f u nction L e ( t, e) {  v o id  0 === e && (e   = {}); var i =  e, n = i.placement,  s  =  i.boundary, o = i. ro otBoundary, r = i.pad din g ,  a = i.flipV a riati o ns, l = i . al lowe d Auto Placement s , c = void 0 === l ? Lt :  l,  h  = ce(n), d =  h  ? a  ? kt : kt.filter(( fun c tion (t) { re tu rn c e(t)   = == h } ) )  : yt, u =  d.filter ((function  (t ) { retur n c.indexO f( t) >= 0 }));  0  == = u.le n gth && (u = d); v a r  f = u.reduce ( ( fu n c ti on (e, i )  { return e[i ] = ke (t, { placement:  i,  b oundar y:  s,  rootBound ar y: o, padding: r })[Ut(i)], e } ),  { }); return Obj e ct.key s(f ) .s or t ((fu nctio n  ( t ,  e) { return f[t] -   f [e] }) ) }   c on s t  x e  = { name: "flip" ,   enable d:  ! 0 ,  p ha se: "main", fn:  fu nc ti o n (t)  { v a r  e  =  t. state,  i   =   t.options,  n = t.na me; if (!e.modifi ers Data[n]. _skip) { for (var  s  = i .mainAxis, o =  vo id 0 ===  s  || s, r =  i .altAxi s ,  a = void 0  ===  r || r ,  l  =   i.f a l lba c k P laceme nt s, c = i.pa dding, h  =  i .boun d ary, d = i .r ootBound a ry, u = i.al t Bo unda ry, f = i . flipVariations, p  =  void 0 == = f  || f, m = i.al l o wedAutoPla cemen t s, g  =  e.options.place m ent, _ = Ut(g), b =  l  ||  (_ !==  g &&  p  ? fun ct i o n (t) {  if  ( Ut(t)   === vt ) return []; var e = ge(t) ; r et u rn [be(t), e, be(e)] }(g) : [ge(g) ]),   v = [g].concat (b) . redu ce( (fu ncti o n (t, i) { r eturn t.concat(Ut(i)  = = = vt ? Le(e, { pla cem en t : i,  b oundary: h , rootBoundary:  d ,   padding: c, flipV ar ia t ions: p,  allowedAutoPlace ments: m } ) : i) }),  []),  y = e.rects.refer ence, w  = e.re ct s .p o ppe r, E  = new Map, A = !0, T = v[0] , O   = 0; O < v. length ; O++) { var C = v[O], k  =  Ut(C), L = ce(C)  ===   wt, x = [mt, gt] .ind exOf(k) >= 0, D = x ? "width" : "hei ght " , S =   ke(e, {   p lacement:  C ,  bound ary :   h,   ro o t Boundary:  d , altBounda ry : u, padd i ng: c   }),  N = x  ?  L ?  _t  : bt : L  ?  gt : mt ;  y[ D] > w[D ]  && (N =  ge ( N) ) ; va r I = ge(N ),  P = []; if  (o && P. pu s h( S[k]   <= 0) ,  a && P.pus h ( S[N] <= 0, S [ I ] <= 0),  P. every( (fu n ction ( t )  { return  t })) ) { T  = C, A  = ! 1; break } E.set(C,  P) } if  (A)  fo r (var  j  =  function (t )  { var e = v.find((f unction (e) { var i = E.get(e); if ( i)  r eturn i.slice(0, t).every((fun c tion (t) { return  t }))  }));  if  (e) r e tu r n  T = e, "break" }, M = p ?  3 : 1 ; M  >  0 && "br e ak" ! = = j(M); M--); e.placem e n t !==   T  && (e.mod i f iersDa ta[ n ] ._ s ki p   = !0, e .placement  =  T, e.re se t  =  !0 ) } },  r equiresI fE xists :  ["offset" ] ,  da ta :  { _skip: !1   } } ;   fu n c ti on De(t ,  e , i) { r et u rn void 0 === i && (i = { x:  0,   y: 0 }), { top:  t.to p -  e .height  -  i .y, righ t:  t . right - e.width + i.x , b o ttom: t.bottom - e.height + i.y,  l e f t : t.lef t - e. wid th -  i .x  } } func tion Se( t)   { re t u rn   [m t,  _t, gt , b t].some(( function (e)   { return t[e] >= 0  }))   } const Ne  = {   n am e : "hide", enabled: !0, phase: "main",  re q ui re sIfExists: ["pr ev entOverflow"], fn:  fun c t i on (t)   { var  e   = t. state, i = t.name , n  = e .re cts .re fe r ence , s = e.rects.pop per,  o  = e .mo dif ier sDa ta. pre ven tOverflo w , r = ke(e, { e lementCont ext:  "reference" }),  a =  ke(e, { altBou nda ry: !0 }), l = De (r,  n), c = De(a , s , o), h = Se(l),  d =  Se( c);  e.modi fie rsData [i]  = {  ref erenc eCl ippingOffsets:  l,  popper Esc apeO ffs ets: c, isRefere nce Hidden: h , h asPoppe rEs caped: d } , e .attributes.popper =  Ob ject.assign ({} , e.attribu tes .popp er,  { "data-p opp er-referenc e-h idden ":  h, "data-p opp er-escaped":  d  }) } } , I e = { name:  "o ffset", enabled : ! 0, phase: "m ain ", req uir es: ["popperOf fse ts"], fn: funct ion  (t)  { v ar e  = t .state,  i  = t.options, n  =  t.name, s = i.of fs et,  o   = void 0 == =  s  ? [0, 0]  :   s, r = L t. r educe((fun ct i on (t, i) {  re t urn t[i] = function (t, e, i) { var n =  U t (t), s = [bt, mt].indexOf(n)  >=   0 ? -1 : 1, o = "function" == t yp e of i ?  i( O bject.assign({}, e, { placemen t:   t })) : i, r = o[ 0] ,  a  =  o[1]; re t urn r = r ||  0 ,  a  =  (a || 0) *   s, [bt, _t ]. i nde x Of(n) >= 0 ?   { x: a, y: r }  :  {  x:   r, y: a } }(i,   e.rects, o),  t  } ),  { }), a = r[e. p lacement], l =  a . x,  c  = a.y; null  ! = e.modifiers Da t a .popper Off set s && (e.m odifiersData.poppe rOffsets.x  += l, e. modifier sData.popp erOffsets.y + = c),  e.modifie rs Da ta [ n ] = r }  }, Pe = { name: "popperOf fsets", e nabled: !0, phase:  "read", fn : function (t) { var e = t .state,  i = t.nam e; e.modifier sData[i] = Ce({ reference : e.rects. reference, element :  e.rects.popper, st r ategy: "absolu te " , placeme nt: e.placem e nt })  }, data: {}   }, je = { name: "pr eventOverf l ow", enabled: !0, phase : "main", fn:  f unction (t) { var e  =  t.state, i = t.opti o ns, n = t . name, s = i.mainAxis, o  =  void 0 = = = s || s, r = i.a l tAxis, a  =  void 0  ! == r && r, l = i.bound a ry, c = i.r o otBoundary,   h = i. a lt Boundary, d = i.p ad ding, u = i.tether, f = vo id 0 == = u ||  u ,  p = i.tetherO ffset, m = vo id  0  === p ? 0 : p, g = ke(e,  { boundary: l, roo tBoundary: c, paddin g: d, a ltBound a ry: h }), _ = Ut(e.placement), b = ce(e .placement), v   = !b, y = ee(_), w = "x" === y  ? "y" :  "x", E  =  e.modifiersData.poppe rOffsets, A =  e.rects.reference, T = e.re ct s.popper, O = "function"  ==  typeof m ? m(Object.assign({}, e.rects, { plac em ent: e. placement }) ) : m , C = { x: 0, y: 0 };  if (E) { if (o || a) { var k = "y" === y ?  mt :  bt, L = "y" === y ? gt : _t,  x = "y" === y ? "height" : "wid th", D = E[y], S = E[y]  + g[k], N = E[y] - g [L ] , I =  f  ?  -T[x] / 2 : 0, P  =  b === wt ? A[x] : T[x], j  = b ===  wt ? - T [ x] : -A[x], M  = e.elements. ar row, H = f && M ? Kt( M ) : { wid t h: 0, height :  0 }, B = e.modifiersDat a["arrow#persis t ent"] ?  e .modifiersData [ "arrow#persistent"].p adding : { t op : 0, right: 0, bottom :  0, left: 0 }, R   = B[k], W = B[L], $ = oe (0, A[x], H[x]), z  = v ? A[x] / 2 - I  -  $ - R - O : P -  $ - R - O, q = v ? -A[x] /  2  + I + $ + W + O : j + $ + W + O, F = e.element s. arrow &&  te(e.elemen ts.ar row), U = F  ?  "y" === y ? F.clientTop  || 0 : F.clientLeft || 0 : 0, V  = e.modifiersData.offset ? e.modif iersData.offset[e.placement][y] : 0, K = E[ y] + z -  V - U, X = E[y] + q - V; if (o) {  var Y = o e(f ? ne(S, K) : S, D, f  ? ie(N, X) : N); E[y ] =   Y, C[y] = Y -   D  }  i f  (a) { var Q = "x" === y ? m t : bt, G = "x" === y ? gt : _t, Z = E [w],  J  = Z  +  g[Q], tt = Z - g[G], et = oe(f  ? ne(J,  K ) : J, Z, f ? ie(t t,  X) : tt); E[w]  =  et, C[w]  =  et - Z } } e.modifiersData[n] = C } }, re quiresIfExists: ["offset"] }; function Me(t, e, i) { void 0 === i && (i = !1); var n = zt(e); zt(e) && function (t) { var e = t.getBoundi ngClient R ect(); e.width,  t .o ffsetWi dth , e .height, t.offsetHeight }(e); var s, o, r = Gt(e), a = Vt(t), l = { scrollLeft: 0, s croll T op: 0 }, c = {  x: 0, y : 0  }; return (n || !n &&   ! i )   && (("body" !== Rt(e) ||  w e ( r)) && (l = (s = e) !== W t (s) && z t( s) ? { scrollLeft: (o = s).sc ro ll L eft, scrollTop: o.scroll Top } :   ve(s)), zt(e) ? ((c = Vt ( e )).x += e.clientLef t,  c.y += e.cli ent Top) :  r  & & ( c.x = ye(r)) ), { x: a.le f t + l .scrollLeft  -  c .x , y: a.top + l.scrollTop - c.y , width:  a.width,  h eight: a.h e ight } } funct i on He(t) { var e = new Map, i =   new Set, n = [];  f unction s(t) { i.add(t.name) , [].c o ncat(t.requires   || [],  t .requiresIfExists || []). fo rEach((function (t) { if (!i.has( t)) { var  n  = e.get(t); n && s(n) } })), n.push (t) } retu rn t.fo r Each( (fu nction (t) { e.set(t.name, t) })), t.forEach((function (t) { i.has(t.n ame) || s(t) })), n } var Be = { plac e m e nt :  " b o t to m ",   modifiers: [],  s trategy: "a bso lute" }; function Re() { for (va r  t = argumen t s.len g th, e =   n e w Array(t), i  = 0;  i < t; i ++ )e[i] =  a rguments[i]; return  ! e.some((function ( t) {  r eturn !(t  &&  "functi o n "  == t ypeof t.getBou n d i ngClientRect) }))  }  functi o n  We(t) { v oid 0 === t && (t = { }); var e  =  t, i  = e.defaultModifie rs, n =  v oid 0 ===  i ? [] : i, s = e.de f au l tOpti ons, o =  void 0 = = = s ? B e : s; return fun c ti on  (t, e , i) { v oid  0 === i && (i = o);  v ar s, r, a =   {  place ment: "bottom" , ordere dM odif i ers:  [], options:  Ob ject.assign({}, Be, o), modifier s Data: {}, elements: { refere n ce: t, popper: e }, attri b u tes: {}, styles:  {} } ,  l = [],   c  =  !1, h  =  { state: a, setOptions: function (i) { var s = "function" == typeof  i ? i(a.options) : i;  d(), a.o pt ions  =   Obj ect .assign({}, o, a.option s , s), a.scrollParents = {   reference: $t(t) ? Ae(t) :  t . context E lement ? Ae(t.contextElement ) :  [ ], popper :  Ae(e) };  v ar  r, c,  u =  func tion (t) { var e = He(t); return Bt.reduce((fu nction   (t,   i) { return t.concat ( e. fi lt er ((f unction  (t ) { ret urn  t.pha se  ===  i } ))) }),  []) }( (r = [] . concat(n, a .op tions. m od i f iers), c  =   r. redu c e((func t ion (t, e) { var i =  t[ e.n am e] ; r eturn t[e.name] = i  ? Object. as sign({}, i, e,  { options : Objec t . assign({}, i.o ptions, e. op ti ons ) , data:   Object.assign({},   i .data, e.data) }) :  e,  t }), {}), Object.keys (c ).map((f unc tion (t) { return c [t ]  }) ))); retu rn  a.orderedModifiers  =  u. filter((f un ction (t) { return t.enable d  })), a.o rde redMod if iers. for Each( (f unction (t) { var e = t.name, i = t.options, n = void 0 === i  ? {} : i , s = t .ef fect;  if  ("function"  = =  t ypeof s) { var o =   s ({ state: a, name: e, instance :  h, options :  n }); l.push ( o || function () { }) } })), h. u pd ate() }, forceUpdate: function () { if (! c ) { v ar  t  =  a.ele men ts ,  e = t. ref er en ce, i  =  t. po pper; if (Re(e, i)) {   a.rects = { refe rence:  Me(e, t e (i), "fixed" === a.options.s tr ate gy ), po ppe r:  Kt(i) } ,  a.reset = !1, a.plac ement = a.options.pl acement,  a.orde redModi f iers.forEach((fu n ctio n  (t) { retur n a.mod i f iersData[t.name] = Object. as sign({ },  t.d ata) })); fo r ( va r  n = 0 ; n  <   a. or deredModi fiers.length; n++)if (!0 ! = = a. re se t) {  var  s  =  a.orderedModifie rs[n], o   =  s.fn, r = s.o pti ons , l = void 0 === r ? {} :  r, d = s.name;  "f unc tion" == typeof o && (a =  o({ state: a,  opt ions: l, name:  d, instance: h  }) || a) } else a.reset = !1 , n = -1 } } },  update: (s =  fun cti on () { r etu r n new Promise((func tion (t) { h.forceUpdate(), t(a) }))  }, f unctio n () { r e turn r || (r = new Promise((function (t) { Promise.r es o lve().then((fu nction ( )  { r = void 0 ,  t(s()) })) } ) )), r }), des t roy: funct i on () {   d(), c = !0 } }; if (!Re(t, e)) retur n h; function d() { l.forEach((fu n ct i on (t)   { retur n  t() })), l = []  } return h.setOptions(i ).then((function (t) { !c && i.onFirstUpd ate && i.onFirs tU pd a t e(t)  })), h } } var $e = We(), ze  = We({ defaultM od if i e rs:  [pe, Pe, ue, Ft] }), qe = We({  defaultModifi er s:   [ pe,   Pe, ue, Ft, Ie, xe ,  je, le, Ne] }); const Fe = Object.freeze ({ __proto__ : null, popperGenerator: We,   detectOv e rflow: ke, createPopperB as e:   $e, cre a tePopper: qe, cr eatePopperLite: ze, top: mt, botto m:  g t ,  ri ght : _t, left: b t,  auto: vt, basePl a cements: yt,  s ta rt: wt,  end: Et, clippingParents: At , v iewport :  Tt, popper: Ot, reference: Ct , variatio n Placements: kt, placements: Lt , b e foreRea d : xt, read: Dt, afterRead: St, beforeMain:  Nt, main: It , afterMain: Pt, beforeWrite: jt, write: Mt , afterWrite: Ht , modifierPhases: Bt, applyStyle s: Ft, arrow: le , computeStyles: ue, eventListen ers: pe, flip:   xe, hide: Ne, offset: Ie ,  p opperOf f sets: Pe, p r ev entOverflow: je }), U e  =  " dropdown", Ve = "Escape",  Ke   = "Space", Xe = "ArrowUp", Ye = "A rr ow D own", Q e  = new RegExp("ArrowU p|A rrowDo wn| E s cape"), Ge = "click.bs.dr o pdown.data-api", Ze = "ke ydo wn.bs.drop d ow n.d a ta-api", Je = "show", ti = '[ da t a-bs - togg l e="dropdo wn"]', ei = ".dropdown-me n u", ii = m() ?  " top-end" : "top-start" ,   n i  = m() ?   " top-start"  : "top-end", si  = m() ? "b ott om-end" : " bot tom-start",  oi = m( ) ? "bottom-st art"  :  " b o ttom-end",  ri = m()  ? "left-s tart" : "r ight-start" , ai = m()  ? "right-st art" : "left-start" , li = { offse t: [0, 2], bounda ry :  " clippin gP a rents", reference: "togg le", dis p lay: "dynamic" ,  popperConfi g : null, autoClose:  !0 }, ci = { off s et:  "(array|stri n g|fu n ction)" ,  boundary: "(string|el e ment)", referenc e: "(string|element|obj ec t)", display: "string" , popperConfig: "(null|object|functio n)", autoClose: "(boolean| st r ing) " };   clas s  hi ext e nds B { constructor(t,   e) { super(t), this._popper = null, this. _config = this._getConfig( e) ,  this._menu = t his. _get M enuE l ement(), this . _i nNavbar = this._ d etectNa v bar() } static get Default() {  return li  }  static get DefaultType () { return ci } static  g et NAME() { return Ue }  toggle() { re t u r n this._isShown() ?  t his.hide() :  t his.sh ow ( )  } sho w() { if (c (t his._ele m e n t)  || this._isSh o wn(this._menu)) r eturn; const  t  = {  r e latedTarg e t: this._element  } ; if (j.trigger(this._element, "show.bs.dropdown", t) .defaultPrevented) retur n;  con st   e = hi.getParentFromElement(t his. _element); this. _ inN a vbar ? U. s etDataAttribute( th is._menu, "popper", " none ") : this._createPopper (e), "ontouchsta r t"  i n document.documentE l emen t && !e.closest(".n avbar-nav") && [].concat ( . ..docume n t .body.childr en).f orEach((t  =>  j .o n ( t, "mouseove r", d))),  this._elem ent.focus () ,  t his._element.set At t ribute("ari a-expand e d", !0), this. _ menu.classLi s t.add(Je), this._el ement.classLis t .ad d(Je), j.trigger(this._el e ment ,  "shown.bs . dropd o wn", t) } hi de () { if (c ( t h is._element)  || !this._isSh ow n( th is._menu))  return; const  t =  { relatedTarge t: this._element }; thi s. _c ompleteHide(t) } dispose( ) { this._popp er && this._popper.destroy( ),  s uper.dispose() } update()  { this._inNav b ar  =  this._detec t Navbar(), this ._ popper && this. _ pop per.update() }  _com p leteHide(t) { j.t r igger ( this._e l e m en t , "hide.bs.d r o p down", t).def au lt Pre vented | |  ( "on t ou chstart" in do cument. documen t Element && [].concat(.. . doc ument.bo d y.childre n ).forEach((t => j.off(t,  "mo us e over", d)) ) , this._po p per && this. _ popper.destroy(),   this. _me nu.cl as sList.remove(Je), this._el e ment.class L is t .remove(Je ) , this._eleme n t.setAtt r i bute(" aria-expand ed ", "fals e " ) ,  U. removeDataAttr ib ute( t h i s._menu,   "popper" ),   j.trigger (t h i s._elemen t,  "hidden.b s.d ropdow n" ,  t) )   } _getCon fig(t) { if (t = {  ...this.c onstructor .Defau lt, ...U. ge tD a taAttributes(this. _e l ement), ...t },  a( U e, t, this.constru ct o r.DefaultType), "object"  ==   typeof t.reference && !o(t. re f erence) && "function" != type of   t.reference.g et B ounding Cl i entRect) throw  new TypeError(`${U e .toUpperCase() }:   Option "r eference" pr o vided type "object"  without a r e quired "getBoundingClientR ect" method.`);  return t } _c r eatePopper(t) { if (void 0  === Fe) throw n e w TypeError("Bootstrap's dro pdowns requir e  Po pper (https://popper.js.o r g)" ); let e = this._elem e nt;  "parent" === t h is._co n fig.reference ? e =  t  : o(this . _config.reference )  ? e = r( t his._conf i g.reference) : "obje c t" == typeo f  this._confi g .refere n ce && (e = th is ._config.reference);  co nst i = this._getPopperC onf i g(), n = i.mod i fiers.find((t => "a pp lyStyles" ===  t .na me && !1 === t.ena bl ed)); this._popper = q e (e,  this._menu, i), n && U. setDataAttribute(this._menu, "po pper", "static") } _i sShown(t = this._elemen t) { return t.classList .contains(Je) } _g etM enu El e ment() { return V.ne xt(this._element, ei)[0] }  _g et P lacement ()  { const t = t hi s._element.parentNode; if  ( t.c las sLis t.contains("dropend"))  r eturn ri; if (t.classLi s t.cont a in s("dropstart"))  r eturn ai; const e = "e nd" ===  g etComputedStyle(this._men u).getPropertyValue("--bs-position ").trim (); return t. c las sList.c o ntains("dropup") ?  e  ?  ni : ii : e ? oi : si   } _d etectNavbar() { return  null !== this._element. closest(".navbar") } _getOffs et() { const { offset: t } = this._ config; return "stri ng"  == typeof t ? t.spl it(" ,").map((t => Number.pa rs eInt(t, 10))) : "fu nction" == typ eo f  t ? e =>   t(e, thi s._element) : t } _getPo pp erConfig () { const t =  { placement: this._getPla cement(), modifiers: [{ name:  "preventOverfl o w", options: {   boundary: this._conf i g.boundary } }, { nam e : "offset", opt ions: { of fset: this._getOffset() } }] };  return "st atic" === this._co nf i g.display && (t.modifi e rs = [{ name: " applyStyles" , enabled: !1  } ] ), { ...t, .. . "functio n "  == ty peof this._config.popperConfig ? this. _config.pop pe rConfig( t )   :  th is._c on fig. p o pperConfig } }  _ selectM e nuItem({ key: t, ta r g et: e }) { const i = V.f ind(".dropdown -menu .dropdown-item:not (. disabled):not(:disabled)", this._ men u).filter(l); i.l en gth && v(i, e, t === Ye, !i.includes (e)).focus() } static jQuer y Interfac e(t) { return this.each((function () { const  e = hi.getOrCreateInstance(this, t); if  ("st ring" == typeof t) { if (void 0 == = e[t]) th row new TypeError(`No m e th o d  named "${t}" ` );  e [t ]() } })) } stati c clearMenus(t) { if (t && (2 == = t.button || "keyup" = ==   t.type && "Tab" != =  t.key)) return; const e = V .find(ti); for (let i   = 0 , n = e.length; i < n; i ++) { const n = h i .getInstance(e [ i] );  if (!n || !1  == =  n._config.autoCl o se) continue;   if (!n._isShown())  con ti nu e ; const s = { related Ta rget:  n. _e l ement }; if (t) { co nst e = t.co m posedPath(), i = e.in cl udes( n._ me nu ); if (e.includes(n._element) ||  "in s ide" === n._config.a uto C lose && !i || "ou t side" === n._ c onfig.autoCl ose  &&  i ) continue; if (n._men u .contains(t.t arg e t) && ("keyu p " === t.type && "Tab" === t . key ||  /input|select|option|textarea|form/i.test (t.t arget.tagName))) continue; "click" === t.typ e && (s.clickEvent = t) } n._completeH ide(s) } } static get P are ntFromElement(t) { retu rn   n(t) || t.parentNode } static dataA piKeydownHandler(t) { if  (/input|textarea/i.test( t.target.tagName) ? t.ke y = ==  K e || t.key !== V e  && (t.key !== Ye & & t .k ey   !== Xe || t.target.closes t (ei)) : !Qe.test(t.key))  r et u rn; cons t e  = this.classLi st .co nta ins(Je); if (!e && t. k ey === Ve)  r eturn; i f ( t.preventDefault(), t .s topPropagation(), c(this)) return;  con st i = this.matches(ti )  ? this : V.p r ev(this, ti)[0], n = hi.getOrCreateInstance(i);   if (t.key !== Ve) return t.k e y  === Xe || t.key === Ye ?  (e || n.show(), void n._selectMenuItem(t))  : void  (e &&   t.key !==  Ke  || hi.clearM en us());   n . hide() } } j.o n ( d o cument, Ze, ti, hi.dataApiKeydownHandl er ),  j.on(do cum ent, Ze, ei ,  hi.dataApiKeyd ow nH an dler), j.on( d ocument, G e, hi.clea rMenus), j.on(document,  " k eyup.bs.dropd o wn .data-api", hi.clearMen us ) , j.on(docu m en t,  Ge, ti, (func tio n (t) { t.prev entDefault(), hi.getOr C reateInstance(t h is).tog g le() })), g(hi); const di  =  ".fixed-top, .fixed-bottom, .is-fixed ,   .sticky-top", ui = ".sticky - t o p ";  cl as s  f i {  co n st ru ct or()  {  this._element = document.body }   getWidth()  {  c on st  t =  d oc um e nt .doc um entElement.clientWidth; return Ma t h.abs(win d ow.innerWidth - t)  }  hide() { const t = this.getWid t h() ; this._disableOverFlow(), this. _ se t ElementAttributes(this._e le m ent, "paddingRight", (e =>  e   + t)),  t his._setElementAttributes(di , " pa ddingRigh t" , (e => e   +  t)), th is. _setE lementAttributes(ui, "marginRight", (e => e -  t)) } _ d isa b l eOverFlow() {  this._saveInitialAttribute (this._element, "overflow") , this._e lem e nt.styl e .overflow = " hidden" } _setElementAttribute s( t, e, i) { const n  = this.g etW id th ( ); this._applyMani pu lationCa llb ack (t ,  (t =>  {  if (t !== th is. _ele ment &&   window.innerWidth > t.cli e nt Width + n) return; this._ saveInitialAttribute(t, e); const s =  wind ow.get Comput edStyle( t )[e]; t.styl e[ e ]  = `${i(N umb er.parseF loa t(s))}p x`  } ))   }  reset()  { this._re setElemen tAttribute s(this. _element,  " ov e rflow") ,  t his._resetElementA tt r ibutes(this._element,  "paddingRight"), t h is._resetEleme nt A ttributes (di, "paddin g Right"), this._rese tElementAttri b ute s(ui, "marginR i ght") } _saveInitialAttribu te(t, e) { cons t  i = t.style[e]; i && U.setD ataAttribute(t, e, i) } _ r esetElementAttrib u tes(t, e)   { this._applyManipul a tionCallb a ck(t, (t  = > { const i = U.getD a taAttribute ( t, e); void  0  === i  ?  t.style.remo ve Property(e) : (U.removeD ataAttribute(t, e),  t .style[e] = i)   })) } _applyManipul at ionCallback(t,   e)  { o(t) ? e(t) : V.find(t, this . _element). forEach(e) } isOverflo wing() { return thi s. getWidth() > 0 }  } const pi = { className: "modal-backdrop",  isVisible: !0, isAnimated: !1, rootEleme nt:  "body", clickCallback: null }, mi  = { classN ame: "string", isVisible: "boole an", isAnimated: "boole an " , rootElement: "(el em ent|string)", clickCallback : "(function|null)" }, g i = "show", _i = "mou s edown.bs.backd r op ";  class bi { con stru c tor(t)   { this._confi g  = this._getConfig(t), thi s._isAppended = !1, this._element = n ul l } show(t) { this._config.isV isible ? (this._appen d(), this._co n fig .isAnimated && u(this._getElement() ), this._getElement(). classList.add(gi), this ._ e mulateAnimation((() => { _(t) }))) : _(t)  } h ide(t) { this._config.isVisible ? (this._get Element().classList.remove(gi), this._ emulateAnimation((() => { this . dispose() , _(t) }))) : _(t)  }  _getElement() { i f (!this._element) { con st  t =  document.crea teEle m ent("div" ) ; t.className = this._con fig.className, this._config.i sAnimated && t. c lassList.add( " fade"),  t h is._el ement = t } return this._element } _ge tConfig(t)  {  return ( t   =  {  . ..pi,  . .."o b j ect" == typeof t ? t  :  {} }).rootElem ent = r(t. rootElement), a("back drop", t,  mi), t } _append() { t his._isAppe nde d || (this._ config.rootElement.append (this._getElem en t( )), j.on(th is . _getElement(), _i, (()   => { _(this._co nfig.clickCa llback) })),  th i s._isAppended = !0)  }  dispose() { this._ isAppended && (j.off(this._elem en t,   _i), this._element.re mo ve(), th is. _isAp pe nded = !1)  } _ e mulateAnimation(t) { b(t,   this._getElement(), this._ co n fig.isA n imated) } } const vi = { tra pEl em ent: null ,  autofocus :  ! 0 }, yi  =  { tr ap Element: "element ",  autofocus: " boo le an" }, wi = ".bs.focustrap", Ei = "backward";  class Ai {   con s t ructor(t) { th is._config = this._getConfig(t ), this._isActive = !1, this._l astTabNav Dir e ction =   null } a ct ivate( ) { const { trapElement: t, au to focus: e } = this._ config;  this._i sActive  ||  (e  &&   t.focus () , j.off(docu ment , wi),  j .on(document,  " fo c usi n .b s.focustrap", (t => this. _handleFocusin(t))), j.on(document, "k eydo wn.tab.bs.fo custrap", (t => this._handleK eyd ow n(t))), this._isActiv e  = !0) } deactivate() { this._isActive  && (t his._i sActive  =  !1, j.off(document, w i)) } _ handleF ocusin(t) {  const { ta rget: e }  = t,  { trapElement:  i  }  = this._config; if (e === document || e === i || i.contains(e))  re t urn; const n = V.focusableChildren(i); 0 === n.length ? i.focus() : this._lastTabNavDirection === Ei ? n[n.length - 1].focus() : n[0] .f o cus ()  }   _handle K eydown(t) { "Tab" === t.k ey  && (this._last TabNav Direction  =  t.shiftKey ? Ei : "forward")  }  _getConfig(t) { retur n t = {   ...vi, ..." ob ject" == typeof t ? t  : { } }, a ( "f o c ustrap",  t ,  y i), t  } } const Ti =  "moda l",  Oi =  "E sc ape", Ci = { b ac kd r op : !0, keybo ard: !0,  fo cu s:  !0 }, ki  =  { backdro p: "(boolean |string ) ", keyboard: "boolean", focus: "boolean"  }, Li = "hidd e n .bs.modal", xi = "show.bs.modal", Di = "res ize .bs.mo d al " ,  Si = "cl i c k. dism i ss.bs.m o dal",   N i = "keydown.dismiss.bs.m od al", Ii = "mousedown.dismiss. b s.modal", P i = "mod a l-open" ,  ji = "show", Mi = "modal-s t a tic"; class Hi e xt end s B  {  cons tructor(t, e )  {  supe r( t) , this._config = this._getCon fig ( e), this._dialog = V.fi n dOne(".m o dal-dialog ",   this._element), this ._backdrop =  this._initiali ze B a ckDrop(),  this._focu strap = t his._init ialize FocusTrap(), this._isShown =  !1, thi s._ignore Backdr opClick = !1, this ._isT ransitioni ng = !1,  this._scrollBar = n ew fi } st atic get Default() {  return  Ci } static get NAME() {  return Ti  } toggle(t) { return this._ isShown ? this.hide () : thi s.show(t)  } show(t) { this._ isShown || t his._isTransitioning  || j.tri gger(this. _element, x i, { relatedTarget : t }).def aultPreve nted || (this ._isShown = !0, this._is An im a t ed()  && (thi s._i sTrans itioni ng  =  !0),  t his._scr ollBar. hide(), d ocume nt. b ody.cla s sList. ad d( P i ), this._a dju stDialog( ), this._setEscapeEvent(), this._setResizeEvent(), j.on(this._dialog, Ii, (() => { j.one(this._element, "mouseu p.dismis s.bs.modal", ( t => {  t. target  = == th is. _element  &&  (this._ign oreBac kdropCl ick  =  !0) })) }) ),  this._showBackdrop( (() =>  this._sh owElement (t)))) }  hide() {  if (!this._isShow n || this._i sTr ansitioni ng)  return; if  (j.t rigger(thi s ._el ement, "h ide.bs .moda l").def aultPre vented) return; th is ._isShown  = !1; c onst t =  this._ isAni mat ed ();  t  &&  (thi s._ isTra nsi tion ing  =  !0) , t his ._s etE sca peE ven t() , t his ._s etR esi zeE ve nt( ), t his._fo custrap.d eactiv ate(), t his._ele ment.class Lis t.r emo ve( ji ),  j.of f(t hi s._ elemen t,  Si),  j.o ff(t his ._di alo g, Ii),  th is ._q ueu eC al lback((() =>  this ._ hi d e Modal ()), this._element , t) }  dispose() { [window,  this ._dialog].forEach( (t =>  j.off(t, ".bs.modal "))), thi s._backdrop.dispose(),  this. _focustrap.deactiva te(), su per.dispose() } handl eUpdate()  { this._adjustDialog( ) } _initia lizeBackDrop() { return  new bi({ is Visible: Boolean(this._ co nf i g.backd ro p ), isAn im a ted: th is . _isAni ma t ed() }) } _initia li z eFocusTra p( )  { return new Ai ({   trapElem en t : this._ element }) } _getC o nfig(t) { retu rn   t  = { ... Ci,  .. .U.getDataAttributes(this._element), ..."object" == typeof t ? t : {} }, a(Ti, t, k i), t } _ showElement(t)  {  co nst e = this. _ is Animated(), i =  V .fi ndOne(".modal-body" ,  th is._dialog);   this. _element.par e ntNode && this._ele ment.par e ntNod e.nodeType === Node. E LEMENT_NODE || docum e nt.body.a p pend(this._elemen t ), this._ e lement.style.displ a y = "bloc k ", this._element.removeA t tribute(" a ria-hidd e n"), this._elem e nt . setAttrib u te("aria-modal" ,  ! 0 ), this._elemen t .setAttribute(" r ole", "dialog"),   this._ele m en t.scrollTop = 0,  i  &&  ( i.scrol l Top = 0), e && u(this._element), this ._element.classList.ad d (ji), this._queueCallbac k((() => { this._config. f ocus && this._ fo c ustrap.activat e( ) , th i s. _isTransitioning = !1, j.trigger(this._elemen t, "shown.bs.modal", { relate dTarge t: t }) }), this. _dial o g , e) } _s e tEscapeEvent() { this._isSho wn ? j.on(this._element, Ni, (t  =>  { this._config.keyboard  && t.key  = == Oi ? (t.prevent Default(), this.hide() ) : this._confi g .keybo a rd  || t.k ey  !== Oi || this._triggerBackd ropTransition() })) : j.off(this._element, Ni) } _setRe si zeEvent() { this._isSh ow n ? j.on(window,  Di, (()  => thi s ._adjustDialog())) : j.o ff(window, Di) } _hideModal()   {  this._element.st y l e.di spl a y  = "none", this._element.setAttribute("aria-hidden", !0), this._ele m ent.removeAttribute("aria- mo dal"), this._elemen t. rem oveAttr ibute("ro le" ), this._isTransition in g = !1,  th is._backdrop.hi de( (() => { document.body.classList.rem ov e(Pi), this._resetAdjus tments(), this._sc rollBar. r eset() , j.tri g ger(this._element, Li )   }) )  }  _ s h ow Backdrop(t) {  j .on(this._elem e nt, S i, (t => { this._ignoreBackdr opClick  ? this._ignoreBackdropClic k = !1 : t.target == = t .currentTarget && (!0 === this._config.backdro p ?  this.hide() : "static "  === this._config.bac kdrop & &  this._tri gg erBackdropTransition()) })),  t his._backdrop.show(t) } _isAnimat ed () { return th i s._element.classList.co n t ains("fade") } _trigger BackdropTransition() { if (j .trig g er(this._e l e m ent, "hidePre vented.b s.modal").defaultPrevented ) retu rn; const { classList: t, scrollHeight: e, style: i } = this._ el ement, n = e  > document.documentEleme nt.clientHeight; !n && "hidden" == = i.overflow Y  || t.contains(Mi) ||   (n || (i.ove r flowY = "hidden") ,  t.add(Mi), this._queueCall back((() => { t.remo ve(Mi),   n || this._queueCallback((() => { i.overflowY = "" }), t h is ._dialog) }), this._dialog), this ._element.focu s()) } _adjustDialog() { co ns t t = this._element.scrollHeight > document.doc um e ntEleme nt.clientHei gh t, e  = this . _scrollBar.getWidth(), i = e > 0 ; (!i && t && !m() || i  & &  !t &&  m ()) && (this._ele ment.style.paddi n gLeft  = `${e}px`), (i && !t & & !m() || !i && t && m()) && ( t his ._ el ement.style.paddi ngRig ht  = `${e}px `)   } _res e tA djustments() {  this._e lement. s tyle.paddingLeft = "" ,  this._element.style.paddi ngRight = "" } static jQueryInterface(t, e) {  return  this.each((function ()  { const i = Hi .getOrCreateInstance(this,  t) ; if ("string" == typeof t) { if (void 0 === i[ t] ) throw  new TypeErro r(`No  method named "${t}"`); i [ t]( e) } })) } } j.on(documen t , " click.bs.modal.data-api",   '[d ata-bs- t oggle="modal"]', (function (t) {  const e = n(this);["A" ,  " AREA"].includes(this.tagNam e)  && t.preventDefa ult () ,  j.one(e, xi , (t => { t.defaultPre vented || j.one(e, Li, (() => { l(this) && this.fo cus() })) })); const i =  V.findOne(".modal.show"); i &&  Hi.getInstance(i).hid e() , Hi.getO rCr eateInstance(e). t og g le(this)   })),  R( Hi), g(Hi);  co nst Bi = "offcanvas",   Ri = { backdrop :  !0, keyboard: !0, scroll: !1 } ,  Wi = { backdro p :  "boolean",  keyboard: "bool ean", s c roll: "boolean" }, $i = "show" , zi = ".of f canvas.show", qi = "hi dden.bs . offcanvas"; cl ass Fi extends B { constru ctor(t, e) { super(t),  thi s._confi g  =  this._g e tConfig(e), t h is._isShown = !1, this._backdr op = this._initi ali z eBackDrop(), this._focust ra p  =  this._ i nitializeFoc usT r ap () ,  this._addEventListeners( )  }  static ge t  NAME() { return Bi  }  s ta tic g et  De fault() { r e tu r n Ri  } to ggle(t) { return t h is._isShown  ? t h is .hide() : th i s.s how(t) } sho w (t) { this._i s Shown || j.trig g er(t his._element, "sho w .bs.offcanvas", { rela te dT a rget:  t }).defaultPrevented  || (this._isShown = !0, th is._element . st y le.visibility   =  " visible",  t his._ba c kdrop.show(), this._config.scroll || (new fi).hide() ,  this._element.remov eAttribute("aria-hidden"), this._elemen t .setAttribute("aria - modal" , !0),  thi s . _elem e nt.set Att r i bute("r o l e ", "dialog"), this._element.cla ss L ist.add( $i ), this._queueCallback((() => { this._config.scroll ||  this._focustrap.activate( ) , j.trigger( t his._ e lement,   " s hown.bs.offca nvas",  { relat ed Target:  t  }) }), this._eleme nt , !0)) } hide() {  this. _ isShown &&  ( j.trigge r ( th is._ element, "hide . b s .offcanvas").defaultPrevent e d || ( this._focu st rap.deac t ivate(), this._elemen t . b lur(), this._isShow n  = !1,  t h is._elemen t. classList. re move( $i), th is._back d rop.hide(), this._q ueueCallback((() => { this._ele m en t .setA ttribute( "aria-hi d den", ! 0), this._element . re m oveAt tribute("aria-moda l"), thi s ._element .removeAttribute("rol e ") ,  this ._elemen t.style. v isibilit y = "hidden", this._config.scroll   ||   (new  fi).reset() , j.trig ger (this. _element, qi)  }) ,  t his._element, !0))) } dispose() { th is. _backdrop.disp o se ( ), this._focustrap. dea ctivate(),  su per.dispose() } _getConfig(t) { retu r n  t = {  . ..Ri,  ...U.getData At tributes(this._element), ..."obj e ct" == typeof t ? t : {} },  a (Bi, t, Wi), t } _initial i z eBackDrop() { return n e w bi({ className: "offcanvas-backdrop", isVisible: this._config.backdrop, isAnimated: !0, rootEl e ment: this._eleme n t.parentNode, clickCallbac k : () => this.hi d e() }) } _initializeFocusTrap() { return n ew   Ai ({ trapE lem en t: this._element })  } _addEventListeners() { j.o n(this._element, "keyd ow n. dismiss.bs.offcan vas", ( t => { th is. _c o nfig.ke y b oar d  & & "Escape" === t.key && this.hide ( ) })) } static jQueryInterface( t )   { r et u rn this.each((function () { const   e = Fi.getOrCreateInstance(this,  t); if ("string" = =  typeof t) { if (void 0  = ==  e[t] || t.starts With("_") || "const ru ctor" === t) throw new  T yp eError(`No metho d  nam ed "${t}"`); e[t](this )  }  } ) ) } } j.on(do cu ment, "clic k. bs.offcanvas.data-api", '[data- bs- toggle="offcanvas"]', (f unction (t) { const e   = n(this); i f   (["A", "AREA"].i ncludes( this.tagN ame) && t .p r e ventDefault(), c ( this)) retu r n; j.on e (e, qi, (() => { l(this) && this.foc u s () })); const i = V.findOne(zi); i && i !== e && Fi.getInsta nc e( i).hide( ),  Fi .g etOrCreateInstance(e).toggle(this) })), j.on(window,  " lo ad.b s. of fcanvas.data-api", (() => V.find(zi).for Ea ch((t => Fi.getOrCreateIn st ance(t).show())))), R(Fi), g(Fi); const  Ui  = new Set(["background", "cite", "h ref" ,  "itemtyp e" ,   " longdesc", "poster", "src", "xlink:h ref " ]) , Vi = /^(?:(?:https?|mailt o|f tp|tel | fi l e|s m s):| [^#&/:?]*(?:[#/?]|$))/i, Ki = /^data:(?: im age\/(?:bmp|g if| jp e g|jpg|png|tif f |w e bp)|video\/(?:mpeg|mp4|ogg |webm)|audio\ / (?: mp3|oga|ogg|opu s) );base64,[\d+/a-z]+= * $/i, Xi =  ( t, e) => { con st   i = t.nodeNam e.t oL ow erCase() ; i f (e.includes(i)) ret u rn !Ui.ha s (i) || Bo ol e a n (Vi.test(t.nodeValue) || Ki.test(t.n ode V al ue)); const n = e.filter((t  =>  t inst a nc e of  R egExp)); for (let t = 0, e = n.length;  t < e; t++)if (n[t].tes t( i)) return !0; return !1 } ; function Yi ( t,  e, i) { if (!t. le ngth) return t; if ( i  && "funct i on" == typeof  i)   return i(t);  con st  n  = (new  win dow.DOMParser).parseF r omString( t , "text/html"), s = [] . con cat(...n.body.querySelectorAll(" *" )); for (let t = 0, i =  s.leng th;  t < i ;  t ++) { const i   = s[t],   n = i.nodeName.toLowerCase(); if (! Object.keys(e).includes(n)) { i. re m ove(); co nt inue } cons t o  =  [ ] .concat(...i.attributes), r  = []. concat(e["* "]  || [],  e[ n ]   | |  []); o.forEa c h( (t  => { Xi(t,  r ) || i.remove A ttribute(t.node Name) }) )  } return n.bod y. innerHTM L   } con st Qi =  "tool tip", G i =  new Set ([ "sanitize", "a ll owList",   "sanitizeFn"]), Zi =  { anima ti on: "boolean", t em plate: "st r ing", title: "(string| eleme nt |function)", trigger: "string" , delay: " (n umber|objec t )", html: "boo lean", selec tor: "(string|b o o lean)", placement: " ( string| f unc tio n)", offset: "(array|stri ng|function)", container: " (st ring|element|bo ol ean)" ,  fallbackPlacemen ts: "arr a y", boundary: "( s tring|e l ement)", customClass:   " (string|function)", sanitize: "boolean", sanitizeFn: "( null| f u nction)", allowList: "object", po pper Con f ig : "(null | o bj ect|func ti on)" }, Ji = { AUTO:  "a uto", TOP: "top", RIGHT :  m() ? "left" : "right " , BOTT OM: "bottom" ,  LEFT: m() ? "right" : "left" } ,  tn =   { anim a t i on :  ! 0, templa t e: '<div class="to oltip" role="tooltip"> <div class="tooltip-arrow"></div><div class="tooltip-inner" > </div></div>', t r igger: "hove r  focus", title: "", delay : 0, html: ! 1 , sel e ctor: !1, placement: "top " , offset: [0, 0], containe r:   !1, fal l backPlacements: ["top", "rig ht" ,  "bottom",  " left"], b o un dary: " cli pping Parents", customClass: "", sanitize: !0, sanit izeFn:   nul l ,  allow List: {  " * ": ["class", " dir", "id" , "lang" , "role ",  /^a ria-[\w- ]*$/i],  a: ["tar get ", "href" , "title", "rel"], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [] ,  im g :  ["src", "srcset",  "alt",  "title", "width", "height"] ,  li :   [], o l: [], p: [], pre:  [], s:  [], small: [], span : [],  sub: [], sup: [],  stron g: [], u: [], ul: [ ] }, popp erConfig: null }, en =  { HID E: "hide.bs.tooltip ", HIDDE N: "hidden.bs.tooltip ", SHOW:  "show.bs.tooltip", SHO WN: "shown. bs.tooltip", INSERTED: " inserted.bs .tooltip", CLICK: "clic k. bs.tooltip", FOCUSI N : "focusin.bs.toolti p ", FOCUSO U T: "focusout.bs.t o oltip" , MOUSEEN T ER: "mouseenter.bs . tooltip",   MOUSELEAVE: "mouseleave. b s.tooltip "  }, nn = "fade" ,  sn = "show", on = "sh ow ", rn = "out", an  =  ".tooltip-in n er", ln = ".modal", cn = "hide .bs.modal", hn =  "hover", dn = "foc us"; class un extends B { cons tructor(t, e) { if  (void 0 === Fe)  t hrow new Type E rror("Bootstrap's tooltips require Popper (https://popper. j s.org)"); super(t), th i s._isE nabled = !0,   this._timeout = 0, this._ h overState = "", this._acti ve T rigger  =  {}, this._popper = null, th is. _c onfig = t hi s._getCon f ig (e), th is. tip =  null, this._setListeners() } static get Defau lt() {   ret u r n tn }  static  g et NAME() {  re t u rn Qi }  st atic ge t Event () { re tu rn  e n   } stati c get Def aultTyp e() { ret urn Zi  } enable() { this. _i sE n abled = ! 0  }  disable() { this._isEnabled = !1 } toggleEnab le d () { this._ isEnabled = !this. _ isEnabled } to gg l e(t) { if  (this._isEnabled)  i f (t)  { c onst e = this._initia l izeOnD e legatedTarget( t); e._activ e Trigger.click = !e. _activeTrigge r .cl ick, e._isWit h Act iveTrigger() ? e._ e nter( null, e) : e._leav e (n ull, e) } else { if (this .getTipElement().class Lis t. contains(sn)) retu rn void this._l eave(null, this ) ; this._enter(null,  t his) } }  d ispose() { clearT i meout(thi s ._timeout ) , j.off ( this._element.close st( ln), cn, this._hideModalHa n dler), t h is. t i p && t his .tip.remove(), this . _ d isposePopper(), supe r . d isp os e () } show() { if ("n o ne " === this._e l eme nt.style.disp l ay)  throw new Error(" P lease use show on visibl e elements "); if (!this.isWithContent ()   || !thi s ._isE n a b l ed) return;  c onst  t  = j . trigger ( this._element, this.constr uc tor.Even t. SHOW), e  = h(th is._element) ,  i  =   null === e  ? this._eleme nt .ownerDocumen t. do cume n tElement.contains (t h is._element) : e.contains (this._element); if (t.d efa u ltPrevent e d || !i) return; "tooltip"  === this.constru ctor.NAME && th i s.tip && this . getTit le ( )  !== t his.tip.querySelector(an).innerHTML &&  (this._dis po sePopper () ,   t h is .tip.remo v e(), this.t ip  = null); const n = this. getTi pE leme n t (), s = (t => {   do { t += Math.floor(1e6 *  Ma th.ran d om()) } while (document.getElem e ntById(t)); return t })(this. c onstructor.NAME);  n .setAttribute("id", s), this._element.s et Attribute("aria-describedby", s), th is._config.animation && n.classList.ad d (nn); const o = "f u nction" == typeof this._co nfi g.plac e ment ? this._confi g .placement.call(this, n, this._element) : this._co n fig.placem e nt, r =   this._getAttachment( o ); this._addAttachme n t Class(r); const { contai n e r: a } = this._conf i g ;  H.set(n, this.construct or .DATA_KEY, this), t his . _e lement.ownerDoc u me nt . documen t Element.contains(this.tip) || (a.a p pen d(n), j.trigger(th is. _ el ement, this.const r ucto r .E vent.INSERTED)), th is . _ popper ? this._p op per.update() : t h is ._popper = qe(this._eleme n t, n,  this._getPopperCon fig (r)),  n .classList.add(sn); c onst l = this._resolveP oss ibleFunction(thi s. _ co nfig.customClass );  l && n .cl assList.add(... l .s pl i t (" ")), "ontouc h sta rt " in document.documentElement &&   [ ].concat(... d ocument.body.child r en ).forEach((t = > { j.o n (t, "mouseover", d)  }) ); const c = this.tip.classList.contains(nn); this . _ queueCallback((() => {  const t = this._hove rState; this._hoverS tate = null, j.trigger(this._element,   this.constructor.Event.SHOWN) , t === rn && this._leave(null, this) }),   this.tip, c)  } hide() { if (!this._popper)  re t urn; cons t t = this.getTipElement(); if (j.trigger (t his._element, this.con structor. Event.HIDE).defaultPrev en t ed) return; t .classList.remove(sn),  "o ntouchstart" in docum ent .doc umentElement && [].concat(...d ocument.body.children).f o rEach((t => j. o ff ( t, "mous e over", d)) ), this._activeTrigger.click =  ! 1, this._activeTrigger.focus = !1, th is ._activeTrigger.hover =  ! 1; const e = this.tip.cla s sList.contains(nn); this._ qu e ueCallb a ck((() => { this._isWithActi veT ri gger() ||  ( this._hov e rS tate != = o n &&  t.remove(), this._cleanTipClass(), this._eleme nt.rem o veA t t ribute("aria -describedby"), j.trigger(thi s._ el e ment, this.constructor.Event.HIDDEN), this. _d isposePoppe r())  }), t his.tip,   e), this. _h o verStat e  =  "" } u pd a te() { nul l  ! == this._popper && this. _popper.update() }   isWithContent() {   return  Bool e an(thi s .g etTitle()) } getTipElemen t( ) { if (this.tip) return this.tip ; c onst t = document .c reateElement("div"); t.innerHTML = th is._con fig.te mplate;   const e = t.child r e n[0]; return this.setContent(e), e.classLis t. rem o ve(nn,  s n),  thi s.tip = e,  t his. tip  } setCont e nt ( t)  {   this._san iti z e AndSetCont e nt ( t, this . g e tTitle(), an ) } _sanitizeA n dSetContent(t,  e, i) { cons t  n  = V. fi ndOne(i, t); e || !n ? th is.setElementC o ntent(n, e) :  n .remove() } setElem en tCon ten t (t , e) { if (null !==  t) ret urn o(e) ? (e = r(e), void (t his ._confi g .h tm l  ? e.parentN ode !== t && (t. i nnerHTML = "",  t.append(e))  :  t.textContent = e.textCo ntent)) : void  ( this._config.h t ml  ?   ( this._config.sani tize && (e =  Yi ( e,  t his._config. al lo w List, t h is. _c onfi g.s anitizeFn) ),  t.i nne rHTML = e)   : t.textConte nt  =  e) } getT itle()  {   c on s t  t = this._element.getAttr i b ut e( "data-bs-original-title") | |  thi s ._ c o nfig.title; return this. _resolvePossibleFuncti on (t)  }  up d ateAttachment(t) { ret ur n  " ri ght "  === t ? "end" : "left"  === t  ?  "start" : t } _initializeOnDelegatedTarget( t, e) { return   e  || this.constructor.get OrCre ate Instance(t.delegateTar ge t, this._getDelegateConfig()) }  _g e tOffset() { const {  offse t:  t } = this._config; re tu rn "string" == typeof t ? t.spl it(" ,").m ap((t => Number.parseInt (t , 10))) : "function"  == t y peof t ? e =>  t (e ,  this ._e lement) :  t  }  _ resolvePossibl e Fu nction(t) { return "function" == typeo f  t ? t. c all(this._element) : t  }  _ getPopperConfig(t) { const  e = { placem en t: t, modifiers: [{ na me: "flip", options: { fallback Pla c e me nts :  this._config.fallbackPla c ements } }, { name: "offse t" ,  option s : { offset: this._getOffset()  }  }, { nam e:  "prevent O ve rflow",  op tions : { boundary: this._config.boundary } }, { nam e: "ar r ow" ,   options: { ele ment: `.${this.construct or.NAME}-arrow` } }, { name: "onChange", enabled: !0, phase: "afterWrite",  fn: t =>  thi s ._han dlePopperPlacementChange(t) }] ,  onFirstUpdate: t =>  { t.op ti ons.placement !== t.placement && th is._ handle PopperPl a cementCh an g e(t) }  };   return  {  . ..e, ..."f un c t ion" == ty peof this. _config.p opperConfi g ? th is._conf ig .p o p perConfig( e)  : this._c onf ig.pop per Co nfig } } _addAttac h mentClass(t) {  t h is.getTip Element().cl a ssList.add(`${this. _getBasicClas s Prefi x()}-${this.updateAttachm e nt( t)}`) } _getAttachment(t) {  r etu rn Ji[t.toUpperCase( ) ] } _setListeners() { th i s._config . trigger.split(" ").f o rEach((t  = > { if ("click" = = = t) j.on ( this._ e lement, this.constructor .Event.CLICK, this._config.select or , (t => this.toggle(t) )); else if ("manual"  != = t) { const e = t === hn ? this.con structor.Event.MOUSEENTER : this.co nstructor.Event.F OCUSIN, i = t === hn ? this.cons tructor.Event.MOUSELEAVE : this. constructor.Event.FOCUS OU T ; j.on(this._element, e, this._conf ig.selector, (t => this. _enter(t))), j.on( this._element, i, this._c onf ig.selector, ( t => this._leave(t))) }  } )), th i s._hideModalHandler = () => { this._ el ement && this.hide() }, j .on(this._element.closest(ln), cn ,  this._hideModalHandler), this._co nfig.selector ? this._c on f ig = { ...this._config, trigger:  "manual", selector: "" } : this._f ixTitle() } _fixTitle() { const t =  this._element.getAttrib ute("title"), e =  typ eof this._elem ent.getAttribute("data-bs - original- t itle"); (t || "string " !== e) && (this._element.setAttrib ut e("data-bs-original-title", t || "" ), !t || this._ e lement.getAtt r ibute("a r i a-labe l") || this._element.textContent || th is._element .s etAttrib ut e ( " a ri a- label ",  t), this._element.setAttribut e ( "title", "")) } _ent e r(t, e) { e = this._i ni tializeOnDelegatedTarget(t ,  e), t && (e._activeTrigger[" fo cusin" === t.t y pe ? dn : hn]  =  ! 0), e.getTi pEl ement().classList.con t ains(sn) || e._ho ve r State  === on ?   e._h overState =  on :  (clearTime out(e._timeout), e._hover S ta te = o n, e ._config.d elay  && e._conf ig.delay.show ? e._timeout =   s etT ime out((() => { e._hoverState === on  && e.s h ow() }), e._conf ig.delay.show ) :   e. show()) } _leave(t, e) {  e  = this._initializeOnDeleg a tedTarget(t, e) ,  t && (e._activeTri gger["focusout" === t .t yp e ? dn : hn] = e._elem ent.co ntains(t.relatedTar get)), e._isWithActi ve Tr igger() || (clearTimeo ut(e._ timeout), e._hoverS tate = rn, e._confi g. de lay && e._config.delay .hide  ? e._timeout = setT imeout((() => { e._h ov er State === rn && e.hide () }) ,  e._config.dela y .hide) : e.hide()) } _isWith ActiveTrigger ( ) {  f or (const t in this._acti v eTrigger) if (this._active Tr i gger[t] )  return !0; return !1 } _get Con fi g(t) { co ns t e = U.g e tD ataAttr ibu tes(t his._element); return Object.keys(e).forEach(( t => { Gi. h as( t )  && delete e[ t] })) ,  (t =  {  ...this .c onstructo r.D efault, . ..e , ..."obj ect " == t ype of t && t  ? t  : {} }) .co ntainer =  !1  ===  t.c ontain er  ? docume nt . body : r(t.container), "number" == typeof t.delay && (t.delay = { show: t.delay, hide: t.delay }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), a(Qi, t, this.constructor.DefaultType), t.sanitize && (t.template = Yi(t.template, t.allowList, t.sanitizeFn)), t } _getDelegateConfig() { const t = {}; for (const e in this._config) this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]); return t } _cleanTipClass() { const t = this.getTipElement(), e = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g"), i = t.getAttribute("class").match(e); null !== i && i.length > 0 && i.map((t => t.trim())).forEach((e => t.classList.remove(e))) } _getBasicClassPrefix() { return "bs-tooltip" } _handlePopperPlacementChange(t) { const { state: e } = t; e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement))) } _disposePopper() { this._popper && (this._popper.destroy(), this._popper = null) } static jQueryInterface(t) { return this.each((function () { const e = un.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } g(un); const fn = { ...un.Default, placement: "right", offset: [0, 8], trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>' }, pn = { ...un.DefaultType, content: "(string|element|function)" }, mn = { HIDE: "hide.bs.popover", HIDDEN: "hidden.bs.popover", SHOW: "show.bs.popover", SHOWN: "shown.bs.popover", INSERTED: "inserted.bs.popover", CLICK: "click.bs.popover", FOCUSIN: "focusin.bs.popover", FOCUSOUT: "focusout.bs.popover", MOUSEENTER: "mouseenter.bs.popover", MOUSELEAVE: "mouseleave.bs.popover" }; class gn extends un { static get Default() { return fn } static get NAME() { return "popover" } static get Event() { return mn } static get DefaultType() { return pn } isWithContent() { return this.getTitle() || this._getContent() } setContent(t) { this._sanitizeAndSetContent(t, this.getTitle(), ".popover-header"), this._sanitizeAndSetContent(t, this._getContent(), ".popover-body") } _getContent() { return this._resolvePossibleFunction(this._config.content) } _getBasicClassPrefix() { return "bs-popover" } static jQueryInterface(t) { return this.each((function () { const e = gn.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } g(gn); const _n = "scrollspy", bn = { offset: 10, method: "auto", target: "" }, vn = { offset: "number", method: "string", target: "(string|element)" }, yn = "active", wn = ".nav-link, .list-group-item, .dropdown-item", En = "position"; class An extends B { constructor(t, e) { super(t), this._scrollElement = "BODY" === this._element.tagName ? window : this._element, this._config = this._getConfig(e), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, j.on(this._scrollElement, "scroll.bs.scrollspy", (() => this._process())), this.refresh(), this._process() } static get Default() { return bn } static get NAME() { return _n } refresh() { const t = this._scrollElement === this._scrollElement.window ? "offset" : En, e = "auto" === this._config.method ? t : this._config.method, n = e === En ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), V.find(wn, this._config.target).map((t => { const s = i(t), o = s ? V.findOne(s) : null; if (o) { const t = o.getBoundingClientRect(); if (t.width || t.height) return [U[e](o).top + n, s] } return null })).filter((t => t)).sort(((t, e) => t[0] - e[0])).forEach((t => { this._offsets.push(t[0]), this._targets.push(t[1]) })) } dispose() { j.off(this._scrollElement, ".bs.scrollspy"), super.dispose() } _getConfig(t) { return (t = { ...bn, ...U.getDataAttributes(this._element), ..."object" == typeof t && t ? t : {} }).target = r(t.target) || document.documentElement, a(_n, t, vn), t } _getScrollTop() { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop } _getScrollHeight() { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) } _getOffsetHeight() { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height } _process() { const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), i = this._config.offset + e - this._getOffsetHeight(); if (this._scrollHeight !== e && this.refresh(), t >= i) { const t = this._targets[this._targets.length - 1]; this._activeTarget !== t && this._activate(t) } else { if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear(); for (let e = this._offsets.length; e--;)this._activeTarget !== this._targets[e] && t >= this._offsets[e] && (void 0 === this._offsets[e + 1] || t < this._offsets[e + 1]) && this._activate(this._targets[e]) } } _activate(t) { this._activeTarget = t, this._clear(); const e = wn.split(",").map((e => `${e}[data-bs-target="${t}"],${e}[href="${t}"]`)), i = V.findOne(e.join(","), this._config.target); i.classList.add(yn), i.classList.contains("dropdown-item") ? V.findOne(".dropdown-toggle", i.closest(".dropdown")).classList.add(yn) : V.parents(i, ".nav, .list-group").forEach((t => { V.prev(t, ".nav-link, .list-group-item").forEach((t => t.classList.add(yn))), V.prev(t, ".nav-item").forEach((t => { V.children(t, ".nav-link").forEach((t => t.classList.add(yn))) })) })), j.trigger(this._scrollElement, "activate.bs.scrollspy", { relatedTarget: t }) } _clear() { V.find(wn, this._config.target).filter((t => t.classList.contains(yn))).forEach((t => t.classList.remove(yn))) } static jQueryInterface(t) { return this.each((function () { const e = An.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } j.on(window, "load.bs.scrollspy.data-api", (() => { V.find('[data-bs-spy="scroll"]').forEach((t => new An(t))) })), g(An); const Tn = "active", On = "fade", Cn = "show", kn = ".active", Ln = ":scope > li > .active"; class xn extends B { static get NAME() { return "tab" } show() { if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(Tn)) return; let t; const e = n(this._element), i = this._element.closest(".nav, .list-group"); if (i) { const e = "UL" === i.nodeName || "OL" === i.nodeName ? Ln : kn; t = V.find(e, i), t = t[t.length - 1] } const s = t ? j.trigger(t, "hide.bs.tab", { relatedTarget: this._element }) : null; if (j.trigger(this._element, "show.bs.tab", { relatedTarget: t }).defaultPrevented || null !== s && s.defaultPrevented) return; this._activate(this._element, i); const o = () => { j.trigger(t, "hidden.bs.tab", { relatedTarget: this._element }), j.trigger(this._element, "shown.bs.tab", { relatedTarget: t }) }; e ? this._activate(e, e.parentNode, o) : o() } _activate(t, e, i) { const n = (!e || "UL" !== e.nodeName && "OL" !== e.nodeName ? V.children(e, kn) : V.find(Ln, e))[0], s = i && n && n.classList.contains(On), o = () => this._transitionComplete(t, n, i); n && s ? (n.classList.remove(Cn), this._queueCallback(o, t, !0)) : o() } _transitionComplete(t, e, i) { if (e) { e.classList.remove(Tn); const t = V.findOne(":scope > .dropdown-menu .active", e.parentNode); t && t.classList.remove(Tn), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !1) } t.classList.add(Tn), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !0), u(t), t.classList.contains(On) && t.classList.add(Cn); let n = t.parentNode; if (n && "LI" === n.nodeName && (n = n.parentNode), n && n.classList.contains("dropdown-menu")) { const e = t.closest(".dropdown"); e && V.find(".dropdown-toggle", e).forEach((t => t.classList.add(Tn))), t.setAttribute("aria-expanded", !0) } i && i() } static jQueryInterface(t) { return this.each((function () { const e = xn.getOrCreateInstance(this); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } j.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', (function (t) { ["A", "AREA"].includes(this.tagName) && t.preventDefault(), c(this) || xn.getOrCreateInstance(this).show() })), g(xn); const Dn = "toast", Sn = "hide", Nn = "show", In = "showing", Pn = { animation: "boolean", autohide: "boolean", delay: "number" }, jn = { animation: !0, autohide: !0, delay: 5e3 }; class Mn extends B { constructor(t, e) { super(t), this._config = this._getConfig(e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get DefaultType() { return Pn } static get Default() { return jn } static get NAME() { return Dn } show() { j.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(Sn), u(this._element), this._element.classList.add(Nn), this._element.classList.add(In), this._queueCallback((() => { this._element.classList.remove(In), j.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide() }), this._element, this._config.animation)) } hide() { this._element.classList.contains(Nn) && (j.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.add(In), this._queueCallback((() => { this._element.classList.add(Sn), this._element.classList.remove(In), this._element.classList.remove(Nn), j.trigger(this._element, "hidden.bs.toast") }), this._element, this._config.animation))) } dispose() { this._clearTimeout(), this._element.classList.contains(Nn) && this._element.classList.remove(Nn), super.dispose() } _getConfig(t) { return t = { ...jn, ...U.getDataAttributes(this._element), ..."object" == typeof t && t ? t : {} }, a(Dn, t, this.constructor.DefaultType), t } _maybeScheduleHide() { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout((() => { this.hide() }), this._config.delay))) } _onInteraction(t, e) { switch (t.type) { case "mouseover": case "mouseout": this._hasMouseInteraction = e; break; case "focusin": case "focusout": this._hasKeyboardInteraction = e }if (e) return void this._clearTimeout(); const i = t.relatedTarget; this._element === i || this._element.contains(i) || this._maybeScheduleHide() } _setListeners() { j.on(this._element, "mouseover.bs.toast", (t => this._onInteraction(t, !0))), j.on(this._element, "mouseout.bs.toast", (t => this._onInteraction(t, !1))), j.on(this._element, "focusin.bs.toast", (t => this._onInteraction(t, !0))), j.on(this._element, "focusout.bs.toast", (t => this._onInteraction(t, !1))) } _clearTimeout() { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface(t) { return this.each((function () { const e = Mn.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](this) } })) } } return R(Mn), g(Mn), { Alert: W, Button: z, Carousel: st, Collapse: pt, Dropdown: hi, Modal: Hi, Offcanvas: Fi, Popover: gn, ScrollSpy: An, Tab: xn, Toast: Mn, Tooltip: un } }));
//# sourceMappingURL=bootstrap.bundle.min.js.map